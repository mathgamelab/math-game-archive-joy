<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>🌐 Set Master!</title>
  <style>
    :root {
      /* 색상 시스템 */
      --bg-primary: #f8fafc;
      --bg-secondary: #ffffff;
      --bg-accent: #3b82f6;
      --bg-accent-hover: #2563eb;
      --glass: rgba(255,255,255,0.8);
      --glass-strong: rgba(255,255,255,0.95);
      --txt-primary: #1e293b;
      --txt-secondary: #64748b;
      --txt-white: #ffffff;
      --p1: #ef4444;
      --p1-hover: #dc2626;
      --p2: #06b6d4;
      --p2-hover: #0891b2;
      --accent: #f59e0b;
      --accent-hover: #d97706;
      --ok: #10b981;
      --bad: #ef4444;
      --border: #e2e8f0;
      --border-hover: #cbd5e1;
      --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      
      /* 반응형 크기 시스템 - 모바일 우선 */
      --space-xs: clamp(2px, 0.5vw, 4px);
      --space-sm: clamp(4px, 1vw, 8px);
      --space-md: clamp(6px, 1.5vw, 12px);
      --space-lg: clamp(8px, 2vw, 16px);
      --space-xl: clamp(12px, 2.5vw, 20px);
      --space-2xl: clamp(16px, 3vw, 24px);
      --space-3xl: clamp(20px, 4vw, 32px);
      
      --font-xs: clamp(0.6rem, 2vw, 0.75rem);
      --font-sm: clamp(0.7rem, 2.2vw, 0.875rem);
      --font-base: clamp(0.8rem, 2.5vw, 1rem);
      --font-lg: clamp(0.9rem, 2.8vw, 1.125rem);
      --font-xl: clamp(1rem, 3vw, 1.25rem);
      --font-2xl: clamp(1.2rem, 3.5vw, 1.5rem);
      --font-3xl: clamp(1.4rem, 4vw, 1.875rem);
      --font-4xl: clamp(1.6rem, 5vw, 2.25rem);
      
      --radius-sm: clamp(4px, 1vw, 6px);
      --radius-md: clamp(6px, 1.2vw, 8px);
      --radius-lg: clamp(8px, 1.5vw, 12px);
      --radius-xl: clamp(10px, 2vw, 16px);
      
      /* 반응형 컨테이너 크기 */
      --container-max-width: min(1200px, 95vw);
      --modal-max-width: min(800px, 90vw);
      --modal-max-height: min(85vh, 600px);
      --game-max-width: min(1000px, 95vw);
    }
    
    /* 화면 크기별 미디어 쿼리 */
    @media (max-width: 480px) {
      :root {
        --space-xs: 2px;
        --space-sm: 4px;
        --space-md: 6px;
        --space-lg: 8px;
        --space-xl: 12px;
        --space-2xl: 16px;
        --space-3xl: 20px;
        
        --font-xs: 0.6rem;
        --font-sm: 0.7rem;
        --font-base: 0.8rem;
        --font-lg: 0.9rem;
        --font-xl: 1rem;
        --font-2xl: 1.1rem;
        --font-3xl: 1.3rem;
        --font-4xl: 1.5rem;
      }
    }
    
    @media (min-width: 768px) {
      :root {
        --space-xs: 4px;
        --space-sm: 8px;
        --space-md: 12px;
        --space-lg: 16px;
        --space-xl: 20px;
        --space-2xl: 24px;
        --space-3xl: 32px;
        
        --font-xs: 0.75rem;
        --font-sm: 0.875rem;
        --font-base: 1rem;
        --font-lg: 1.125rem;
        --font-xl: 1.25rem;
        --font-2xl: 1.5rem;
        --font-3xl: 1.875rem;
        --font-4xl: 2.25rem;
      }
    }
    
    @media (min-width: 1024px) {
      :root {
        --space-xs: 4px;
        --space-sm: 8px;
        --space-md: 12px;
        --space-lg: 16px;
        --space-xl: 20px;
        --space-2xl: 24px;
        --space-3xl: 32px;
        
        --font-xs: 0.75rem;
        --font-sm: 0.875rem;
        --font-base: 1rem;
        --font-lg: 1.125rem;
        --font-xl: 1.25rem;
        --font-2xl: 1.5rem;
        --font-3xl: 1.875rem;
        --font-4xl: 2.25rem;
      }
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0; color: var(--txt-primary);
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg-primary);
      display: flex; flex-direction: column;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .glass { 
      backdrop-filter: blur(10px); 
      background: var(--glass); 
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .header { 
      text-align: center; 
      padding: var(--space-2xl) var(--space-lg); 
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }
    .title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      position: relative;
    }
    
    .title {
      font-size: var(--font-4xl); 
      font-weight: 800; 
      color: var(--txt-primary);
      margin-bottom: var(--space-sm);
    }
    
    .rules-btn {
      position: absolute;
      right: 0;
    }
    
    .rules-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: var(--space-md) var(--space-xl);
      border-radius: var(--radius-lg);
      font-weight: 700;
      font-size: var(--font-base);
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .rules-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .rules-icon {
      font-size: 1.2rem;
    }
    
    .rules-text {
      font-size: 0.9rem;
    }
    .subtitle { 
      color: var(--txt-secondary); 
      font-size: var(--font-lg); 
      font-weight: 500;
    }

    .info { 
      display: grid; 
      grid-template-columns: 1fr auto 1fr; 
      gap: var(--space-xl); 
      padding: var(--space-xl) var(--space-lg); 
      align-items: center; 
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      max-width: var(--container-max-width);
      margin: 0 auto;
    }
    
    @media (max-width: 768px) {
      .info {
        grid-template-columns: 1fr;
        gap: var(--space-lg);
        text-align: center;
      }
      
      .info .scores {
        order: 1;
        justify-content: center;
        flex-wrap: wrap;
        gap: var(--space-lg);
      }
      
      .info .timer-wrap {
        order: 2;
      }
    }
    
    @media (max-width: 480px) {
      .info {
        padding: var(--space-lg) var(--space-md);
        gap: var(--space-md);
      }
    }
    
    .timer-wrap { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: var(--space-sm); 
    }
    .game-title { 
      font-size: var(--font-3xl); 
      font-weight: 700; 
      color: var(--txt-primary);
      margin-bottom: var(--space-xs);
    }
    .timer { 
      font-size: var(--font-4xl); 
      font-weight: 800; 
      color: var(--accent); 
    }
    .bar { 
      width: min(500px, 80vw); 
      height: var(--space-md); 
      border-radius: 999px; 
      overflow: hidden; 
      background: var(--border); 
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
    }
    
    @media (max-width: 480px) {
      .bar {
        width: min(300px, 90vw);
        height: var(--space-sm);
      }
    }
    
    .bar > div { 
      height: 100%; 
      width: 100%; 
      background: linear-gradient(90deg, var(--ok), var(--accent), var(--bad)); 
      transform-origin: left center; 
      transition: transform 0.3s ease;
    }

    .scores { 
      display: flex; 
      gap: var(--space-2xl); 
      justify-content: center; 
      align-items: center;
      flex-wrap: wrap;
    }
    
    @media (max-width: 768px) {
      .scores {
        gap: var(--space-lg);
      }
    }
    
    @media (max-width: 480px) {
      .scores {
        gap: var(--space-md);
        flex-direction: column;
      }
    }
    
    .score { 
      text-align: center; 
      min-width: clamp(80px, 15vw, 100px); 
      padding: var(--space-lg);
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    
    @media (max-width: 480px) {
      .score {
        min-width: 70px;
        padding: var(--space-md);
      }
    }
    
    .score .label { 
      font-size: var(--font-sm); 
      color: var(--txt-secondary); 
      margin-bottom: var(--space-sm); 
      font-weight: 600;
    }
    .score .val { 
      font-size: var(--font-4xl); 
      font-weight: 900; 
    }
    
    .p1 .val { color: var(--p1); } 
    .p2 .val { color: var(--p2); }
    .combo { 
      font-size: var(--font-sm); 
      margin-top: var(--space-sm); 
      color: var(--accent); 
      font-weight: 700; 
    }

    /* 콤보 표시 스타일 */
    .combo-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 120px;
      height: 90px;
      font-weight: 700;
      color: var(--accent);
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      margin: 0 var(--space-sm);
      gap: var(--space-sm);
    }
    
    
    
    .combo-display .fire {
      font-size: var(--font-2xl);
      line-height: 1;
      animation: firePulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      filter: drop-shadow(0 0 4px currentColor);
    }
    
    .combo-display .text {
      font-size: var(--font-lg);
      line-height: 1;
      color: inherit;
    }
    
    
    /* 콤보 레벨별 색상 변화 */
    .combo-display.combo-level-1 .fire { color: #f59e0b; } /* 주황색 */
    .combo-display.combo-level-1 .text { color: #f59e0b; } /* 주황색 */
    .combo-display.combo-level-2 .fire { color: #ef4444; } /* 빨간색 */
    .combo-display.combo-level-2 .text { color: #ef4444; } /* 빨간색 */
    .combo-display.combo-level-3 .fire { color: #8b5cf6; } /* 보라색 */
    .combo-display.combo-level-3 .text { color: #8b5cf6; } /* 보라색 */
    .combo-display.combo-level-4 .fire { color: #06b6d4; } /* 청록색 */
    .combo-display.combo-level-4 .text { color: #06b6d4; } /* 청록색 */
    .combo-display.combo-level-5 .fire { color: #10b981; } /* 초록색 */
    .combo-display.combo-level-5 .text { color: #10b981; } /* 초록색 */
    
    /* 불꽃 펄스 애니메이션 */
    @keyframes firePulse {
      0%, 100% { 
        transform: scale(1); 
        filter: drop-shadow(0 0 4px currentColor);
      }
      5% { 
        transform: scale(1.02); 
        filter: drop-shadow(0 0 4.5px currentColor);
      }
      10% { 
        transform: scale(1.05); 
        filter: drop-shadow(0 0 5px currentColor);
      }
      15% { 
        transform: scale(1.08); 
        filter: drop-shadow(0 0 5.5px currentColor);
      }
      20% { 
        transform: scale(1.1); 
        filter: drop-shadow(0 0 6px currentColor);
      }
      25% { 
        transform: scale(1.12); 
        filter: drop-shadow(0 0 6.5px currentColor);
      }
      30% { 
        transform: scale(1.15); 
        filter: drop-shadow(0 0 7px currentColor);
      }
      35% { 
        transform: scale(1.12); 
        filter: drop-shadow(0 0 6.5px currentColor);
      }
      40% { 
        transform: scale(1.1); 
        filter: drop-shadow(0 0 6px currentColor);
      }
      45% { 
        transform: scale(1.08); 
        filter: drop-shadow(0 0 5.5px currentColor);
      }
      50% { 
        transform: scale(1.05); 
        filter: drop-shadow(0 0 5px currentColor);
      }
      55% { 
        transform: scale(1.02); 
        filter: drop-shadow(0 0 4.5px currentColor);
      }
      60% { 
        transform: scale(1); 
        filter: drop-shadow(0 0 4px currentColor);
      }
      65% { 
        transform: scale(1.02); 
        filter: drop-shadow(0 0 4.5px currentColor);
      }
      70% { 
        transform: scale(1.05); 
        filter: drop-shadow(0 0 5px currentColor);
      }
      75% { 
        transform: scale(1.08); 
        filter: drop-shadow(0 0 5.5px currentColor);
      }
      80% { 
        transform: scale(1.1); 
        filter: drop-shadow(0 0 6px currentColor);
      }
      85% { 
        transform: scale(1.08); 
        filter: drop-shadow(0 0 5.5px currentColor);
      }
      90% { 
        transform: scale(1.05); 
        filter: drop-shadow(0 0 5px currentColor);
      }
      95% { 
        transform: scale(1.02); 
        filter: drop-shadow(0 0 4.5px currentColor);
      }
    }
    
    
    /* 콤보 카드 글로우 효과 */
    .combo-display {
      transition: all 0.3s ease;
    }
    
    .combo-display.combo-level-2 {
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.3);
    }
    
    .combo-display.combo-level-3 {
      box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
    }
    
    .combo-display.combo-level-4 {
      box-shadow: 0 0 20px rgba(6, 182, 212, 0.5);
    }
    
    .combo-display.combo-level-5 {
      box-shadow: 0 0 25px rgba(16, 185, 129, 0.6);
    }
    
    .combo-p1 {
      order: 2; /* 플레이어 1 오른쪽에 배치 */
    }
    
    .combo-p2 {
      order: -1; /* 플레이어 2 왼쪽에 배치 */
    }
    
    .combo-display:empty {
      visibility: hidden;
    }

    .sets { 
      display: flex; 
      justify-content: center; 
      gap: var(--space-xl); 
      margin: var(--space-2xl) auto; 
      flex-wrap: wrap; 
      max-width: var(--container-max-width);
      padding: 0 var(--space-lg);
    }
    
    @media (max-width: 768px) {
      .sets {
        gap: var(--space-lg);
        margin: var(--space-lg) auto;
        padding: 0 var(--space-md);
      }
    }
    
    @media (max-width: 480px) {
      .sets {
        flex-direction: column;
        align-items: center;
        gap: var(--space-md);
        margin: var(--space-md) auto;
        padding: 0 var(--space-sm);
      }
    }
    
    .setbox { 
      border-radius: var(--radius-xl); 
      padding: var(--space-xl) var(--space-2xl); 
      background: var(--bg-secondary); 
      min-width: clamp(200px, 30vw, 350px); 
      text-align: center; 
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      flex: 1;
      max-width: 400px;
    }
    
    @media (max-width: 768px) {
      .setbox {
        min-width: clamp(180px, 25vw, 250px);
        max-width: 300px;
      }
    }
    
    @media (max-width: 480px) {
      .setbox {
        min-width: 120px;
        padding: var(--space-lg) var(--space-md);
        max-width: 100%;
      }
    }
    
    .setbox .name { 
      font-size: var(--font-lg); 
      font-weight: 800; 
      margin-bottom: var(--space-sm); 
      color: var(--txt-primary);
    }
    .setbox .desc { 
      font-size: var(--font-xl); 
      color: var(--txt-primary);
      font-weight: 800;
      white-space: nowrap;
    }
    
    @media (max-width: 768px) {
      .setbox .desc {
        font-size: var(--font-lg);
        white-space: normal;
      }
    }
    
    @media (max-width: 480px) {
      .setbox .desc {
        font-size: var(--font-base);
      }
    }
    

    .number { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      margin: var(--space-2xl) auto; 
      max-width: var(--container-max-width);
      padding: 0 var(--space-lg);
    }
    
    .num { 
      font-size: clamp(3rem, 8vw, 6rem); 
      font-weight: 900; 
      line-height: 1; 
      padding: var(--space-2xl) var(--space-3xl); 
      border-radius: var(--radius-xl); 
      background: var(--bg-secondary); 
      color: var(--txt-primary);
      border: 2px solid var(--border);
      box-shadow: var(--shadow-lg);
      text-align: center;
      min-width: clamp(120px, 20vw, 200px);
    }
    
    @media (max-width: 768px) {
      .number {
        margin: var(--space-lg) auto;
        padding: 0 var(--space-md);
      }
      
      .num {
        padding: var(--space-lg) var(--space-xl);
        min-width: clamp(100px, 25vw, 150px);
      }
    }
    
    @media (max-width: 480px) {
      .number {
        margin: var(--space-md) auto;
        padding: 0 var(--space-sm);
      }
      
      .num {
        padding: var(--space-md) var(--space-lg);
        min-width: 80px;
      }
    }
    

    .controls { 
      display: grid; 
      grid-template-columns: repeat(2, minmax(280px, 1fr)); 
      gap: clamp(20px, 4vw, 32px); 
      padding: 24px clamp(16px, 4vw, 40px) 32px; 
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
    }
    .col { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      gap: 16px; 
    }
    .player { 
      font-size: 1.3rem; 
      font-weight: 800; 
      color: var(--txt-primary);
    }
    .buttons { 
      display: grid; 
      grid-template-columns: repeat(3, minmax(90px, 1fr)); 
      gap: 12px; 
      width: 100%; 
      max-width: 600px; 
    }
    .buttons.any-mode { 
      grid-template-columns: repeat(4, minmax(80px, 1fr)); 
      max-width: 800px; 
    }
    
    @media (max-width: 768px) {
      .controls {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px 16px 24px;
      }
      
      .buttons {
        max-width: 500px;
        gap: 10px;
      }
      
      .buttons.any-mode {
        max-width: 600px;
        gap: 8px;
      }
    }
    
    @media (max-width: 480px) {
      .controls {
        padding: 16px 12px 20px;
        gap: 16px;
      }
      
      .buttons {
        max-width: 400px;
        gap: 8px;
      }
      
      .buttons.any-mode {
        max-width: 500px;
        gap: 6px;
      }
    }
    
    .btn { 
      border: 0; 
      border-radius: var(--radius-md); 
      font-weight: 800; 
      font-size: var(--font-lg); 
      padding: var(--space-sm) var(--space-md); 
      cursor: pointer; 
      transition: all 0.2s ease; 
      box-shadow: var(--shadow);
      min-width: clamp(60px, 12vw, 80px);
      flex-shrink: 0;
      text-align: center;
      line-height: 1.2;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .buttons.hard-mode .btn {
      font-size: var(--font-base);
      padding: var(--space-xs) var(--space-sm);
      min-width: clamp(50px, 10vw, 60px);
    }
    
    @media (max-width: 768px) {
      .btn {
        font-size: var(--font-base);
        padding: var(--space-xs) var(--space-sm);
        min-width: clamp(50px, 15vw, 70px);
      }
      
      .buttons.hard-mode .btn {
        font-size: var(--font-sm);
        padding: var(--space-xs);
        min-width: clamp(40px, 12vw, 55px);
      }
    }
    
    @media (max-width: 480px) {
      .btn {
        font-size: var(--font-sm);
        padding: var(--space-xs);
        min-width: clamp(40px, 18vw, 60px);
        line-height: 1.1;
      }
      
      .buttons.hard-mode .btn {
        font-size: var(--font-xs);
        padding: var(--space-xs);
        min-width: clamp(35px, 15vw, 50px);
      }
    }
    
    .btn:hover { 
      transform: translateY(-2px); 
      box-shadow: var(--shadow-lg);
    }
    .btn:active { 
      transform: translateY(0) scale(0.98); 
    }
    .btn:focus { 
      outline: 3px solid var(--bg-accent); 
      outline-offset: 2px; 
    }
    .p1 .btn { 
      background: var(--p1); 
      color: var(--txt-white); 
    } 
    .p1 .btn:hover { 
      background: var(--p1-hover); 
    }
    .p2 .btn { 
      background: var(--p2); 
      color: var(--txt-white); 
    } 
    .p2 .btn:hover { 
      background: var(--p2-hover); 
    }

    .kbd { 
      opacity: 0.7; 
      font-size: var(--font-xs); 
      margin-left: var(--space-sm); 
      background: var(--border); 
      color: var(--txt-secondary);
      padding: var(--space-xs) var(--space-sm); 
      border-radius: var(--radius-sm); 
      font-weight: 600;
      display: inline-block;
    }
    
    @media (max-width: 768px) {
      .kbd {
        font-size: 0.6rem;
        padding: 2px var(--space-xs);
        margin-left: var(--space-xs);
      }
    }
    
    @media (max-width: 480px) {
      .kbd {
        font-size: 0.5rem;
        padding: 1px 3px;
        margin-left: 2px;
      }
    }
    

    .overlay { 
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex; 
      align-items: center; 
      justify-content: center; 
      background: rgba(0,0,0,0.6); 
      z-index: 50; 
      backdrop-filter: blur(4px);
    }
    .card { 
      width: var(--modal-max-width); 
      max-height: var(--modal-max-height);
      border-radius: var(--radius-xl); 
      padding: var(--space-2xl); 
      background: var(--bg-secondary); 
      color: var(--txt-primary); 
      box-shadow: var(--shadow-lg); 
      border: 1px solid var(--border);
      overflow-y: auto;
      margin: auto;
    }
    
    @media (max-width: 768px) {
      .card {
        width: min(95vw, 600px);
        max-height: 90vh;
        padding: var(--space-xl);
        margin: var(--space-lg);
      }
    }
    
    @media (max-width: 480px) {
      .card {
        width: 95vw;
        max-height: 95vh;
        padding: var(--space-lg);
        margin: var(--space-md);
        border-radius: var(--radius-lg);
      }
    }
    .center { text-align: center; }
    .lg { font-size: 1.5rem; font-weight: 800; color: var(--txt-primary); }
    .muted { color: var(--txt-secondary); }
    .stack { display: flex; flex-direction: column; gap: var(--space-md); }
    .row { display: flex; flex-wrap: wrap; gap: var(--space-lg); align-items: flex-start; }
    .row > * { flex: 1; min-width: 200px; }
    
    @media (max-width: 768px) {
      .row {
        flex-direction: column;
        gap: var(--space-md);
      }
      
      .row > * {
        min-width: auto;
        width: 100%;
      }
    }
    
    @media (max-width: 480px) {
      .row {
        gap: var(--space-sm);
      }
    }
    .select, .input, .seg { 
      background: var(--bg-primary); 
      border: 1px solid var(--border); 
      color: var(--txt-primary); 
      border-radius: var(--radius-lg); 
      padding: var(--space-md) var(--space-lg); 
      font-size: var(--font-base); 
      transition: border-color 0.2s ease;
    }
    .select:focus, .input:focus { 
      outline: none; 
      border-color: var(--bg-accent); 
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    .seg { display: flex; gap: var(--space-sm); }
    .seg button { 
      flex: 1; 
      border-radius: var(--radius-md); 
      background: var(--bg-primary); 
      border: 1px solid var(--border); 
      color: var(--txt-primary); 
      padding: var(--space-sm) var(--space-xs); 
      cursor: pointer; 
      transition: all 0.2s ease;
      font-weight: 600;
      font-size: var(--font-sm);
      min-width: 0;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    @media (max-width: 768px) {
      .seg {
        gap: var(--space-xs);
      }
      
      .seg button {
        padding: var(--space-xs);
        font-size: var(--font-xs);
      }
    }
    
    @media (max-width: 480px) {
      .seg {
        flex-direction: column;
        gap: var(--space-xs);
      }
      
      .seg button {
        padding: var(--space-sm) var(--space-xs);
        font-size: var(--font-xs);
      }
    }
    .seg button:hover { 
      background: var(--border); 
    }
    .seg button.active { 
      background: var(--bg-accent); 
      border-color: var(--bg-accent); 
      color: var(--txt-white); 
    }
    .seg button:focus, .btn:focus, .primary:focus, .outline:focus { 
      outline: 3px solid var(--bg-accent); 
      outline-offset: 2px; 
    }
    .actions { 
      display: flex; 
      gap: var(--space-md); 
      justify-content: flex-end; 
      margin-top: var(--space-lg); 
      flex-wrap: wrap;
    }
    
    @media (max-width: 768px) {
      .actions {
        justify-content: center;
        gap: var(--space-sm);
      }
    }
    
    @media (max-width: 480px) {
      .actions {
        flex-direction: column;
        gap: var(--space-sm);
      }
    }
    .primary { 
      background: var(--ok); 
      color: var(--txt-white); 
      border: 0; 
      padding: var(--space-md) var(--space-2xl); 
      font-weight: 800; 
      border-radius: var(--radius-lg); 
      cursor: pointer; 
      transition: all 0.2s ease;
      box-shadow: var(--shadow);
      min-width: 120px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .primary:hover { 
      background: #059669; 
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }
    .outline { 
      background: transparent; 
      color: var(--txt-primary); 
      border: 1px solid var(--border); 
      padding: var(--space-md) var(--space-2xl); 
      font-weight: 800; 
      border-radius: var(--radius-lg); 
      cursor: pointer; 
      transition: all 0.2s ease;
      min-width: 120px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .outline:hover { 
      background: var(--bg-primary); 
      border-color: var(--border-hover);
    }
    
    @media (max-width: 768px) {
      .primary, .outline {
        padding: var(--space-sm) var(--space-xl);
        min-width: 100px;
        font-size: var(--font-sm);
      }
    }
    
    @media (max-width: 480px) {
      .primary, .outline {
        padding: var(--space-sm) var(--space-lg);
        min-width: 80px;
        font-size: var(--font-xs);
      }
    }

    /* 게임 종료 화면 스타일 */
    .end {
      width: min(500px, 85vw) !important;
      max-width: 500px;
    }
    
    .end .actions {
      justify-content: center;
      gap: var(--space-xl);
    }
    
    .end .primary,
    .end .outline {
      font-size: var(--font-lg);
      padding: var(--space-lg) var(--space-3xl);
      min-width: 140px;
    }
    
    .end .lg {
      font-size: var(--font-3xl);
      font-weight: 800;
      color: var(--txt-primary);
      margin: var(--space-md) 0 var(--space-sm);
    }
    
    .end .muted {
      font-size: var(--font-xl);
      color: var(--txt-secondary);
      font-weight: 600;
    }
    
    @media (max-width: 768px) {
      .end {
        width: min(400px, 90vw) !important;
        max-width: 400px;
      }
      
      .end .actions {
        gap: var(--space-lg);
      }
      
      .end .primary,
      .end .outline {
        font-size: var(--font-base);
        padding: var(--space-md) var(--space-xl);
        min-width: 120px;
      }
      
      .end .lg {
        font-size: var(--font-2xl);
      }
      
      .end .muted {
        font-size: var(--font-lg);
      }
    }
    
    @media (max-width: 480px) {
      .end {
        width: 95vw !important;
        max-width: none;
      }
      
      .end .actions {
        flex-direction: column;
        gap: var(--space-md);
      }
      
      .end .primary,
      .end .outline {
        font-size: var(--font-sm);
        padding: var(--space-sm) var(--space-lg);
        min-width: 100px;
        width: 100%;
      }
      
      .end .lg {
        font-size: var(--font-xl);
      }
      
      .end .muted {
        font-size: var(--font-base);
      }
    }

    .feedback { 
      position: fixed; 
      left: 50%; 
      top: 50%; 
      transform: translate(-50%, -50%); 
      font-size: var(--font-3xl); 
      font-weight: 900; 
      padding: var(--space-sm) var(--space-md); 
      border-radius: var(--radius-xl); 
      z-index: 40; 
      pointer-events: none; 
      opacity: 0; 
      transition: all 0.3s ease; 
      box-shadow: var(--shadow-lg);
    }
    .feedback.show { 
      opacity: 1; 
      transform: translate(-50%, -50%) scale(1.05);
    }
    .feedback.ok { 
      background: var(--ok); 
      color: var(--txt-white); 
    }
    .feedback.bad { 
      background: var(--bad); 
      color: var(--txt-white); 
    }

    .end { gap: var(--space-lg); }
    .hint { 
      font-size: var(--font-sm); 
      color: var(--txt-secondary); 
      margin-top: var(--space-sm); 
    }
    label .lbl { 
      display: block; 
      margin-bottom: var(--space-sm); 
      color: var(--txt-primary);
      font-weight: 600;
    }

    /* Venn Diagram Modal */
    .venn-modal { 
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      z-index: 60; 
      backdrop-filter: blur(4px);
    }
    .venn-card { 
      width: min(600px, 90vw); 
      background: var(--bg-secondary); 
      border-radius: var(--radius-xl); 
      padding: var(--space-lg); 
      color: var(--txt-primary); 
      max-height: 85vh; 
      overflow-y: auto; 
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg);
      margin: auto;
    }
    
    @media (max-width: 768px) {
      .venn-card {
        width: min(500px, 95vw);
        padding: var(--space-md);
        max-height: 90vh;
      }
    }
    
    @media (max-width: 480px) {
      .venn-card {
        width: 95vw;
        padding: var(--space-sm);
        max-height: 95vh;
        border-radius: var(--radius-lg);
      }
    }
    .venn-title { 
      font-size: var(--font-2xl); 
      font-weight: 800; 
      text-align: center; 
      margin-bottom: var(--space-md); 
      color: var(--txt-primary);
    }
    .venn-question { 
      background: var(--bg-primary); 
      padding: var(--space-sm) var(--space-md); 
      border-radius: var(--radius-lg); 
      text-align: center; 
      margin-bottom: var(--space-md); 
      border: 1px solid var(--border);
    }
    .venn-question h2 { 
      font-size: var(--font-3xl); 
      margin: var(--space-sm) 0; 
      color: var(--txt-primary);
    }
    .venn-svg { 
      background: var(--bg-secondary); 
      border-radius: var(--radius-lg); 
      margin: 0 auto var(--space-md) auto; 
      border: 1px solid var(--border);
      width: min(400px, 80vw);
      height: auto;
      display: block;
      max-width: 100%;
    }
    
    @media (max-width: 768px) {
      .venn-svg {
        width: min(350px, 85vw);
      }
    }
    
    @media (max-width: 480px) {
      .venn-svg {
        width: min(280px, 90vw);
      }
    }
    .venn-region { 
      cursor: pointer; 
      transition: opacity 0.2s ease; 
      touch-action: manipulation;
    }
    .venn-region:hover { 
      opacity: 0.6 !important; 
    }
    
    @media (max-width: 768px) {
      .venn-region {
        cursor: pointer;
      }
    }
    .venn-btn { 
      width: 100%; 
      padding: var(--space-sm); 
      border: 0; 
      border-radius: var(--radius-md); 
      font-weight: 800; 
      font-size: var(--font-base); 
      cursor: pointer; 
      margin-top: var(--space-sm); 
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .venn-btn.check { 
      background: var(--bg-accent); 
      color: var(--txt-white); 
    }
    .venn-btn.check:hover { 
      background: var(--bg-accent-hover); 
    }
    .venn-btn.next { 
      background: var(--ok); 
      color: var(--txt-white); 
    }
    .venn-btn.next:hover { 
      background: #059669; 
    }
    .venn-result { 
      padding: var(--space-lg); 
      border-radius: var(--radius-lg); 
      margin-bottom: var(--space-lg); 
      text-align: center; 
    }
    .venn-result.correct { 
      background: #d1fae5; 
      color: #065f46; 
      border: 1px solid #a7f3d0;
    }
    .venn-result.wrong { 
      background: #fee2e2; 
      color: #991b1b; 
      border: 1px solid #fecaca;
    }
    .venn-help { 
      background: var(--bg-primary); 
      padding: var(--space-lg); 
      border-radius: var(--radius-lg); 
      font-size: var(--font-sm); 
      text-align: center; 
      color: var(--txt-secondary); 
      border: 1px solid var(--border);
    }
    .venn-timer {
      margin-top: var(--space-lg);
      text-align: center;
    }
    .venn-timer-bar {
      width: 100%;
      height: var(--space-sm);
      background: var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }
    .venn-timer-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--ok), var(--accent), var(--bad));
      width: 100%;
      transition: width 0.3s ease;
    }
    
    .footer {
      text-align: center;
      padding: var(--space-xl);
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      color: var(--txt-secondary);
      font-size: var(--font-sm);
      line-height: 1.6;
    }
    .footer a {
      color: var(--bg-accent);
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }

    /* Mode Selection Buttons */
    .mode-btn {
      border: 0;
      border-radius: var(--radius-lg);
      font-weight: 800;
      font-size: var(--font-base);
      padding: var(--space-md) var(--space-2xl);
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      color: var(--txt-white);
      min-width: 120px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .mode-btn:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }
    
    .mode-btn:active {
      transform: translateY(0) scale(0.98);
    }
    
    .mode-btn:focus {
      outline: 3px solid var(--bg-accent);
      outline-offset: 2px;
    }
    
    .practice-mode {
      background: #06b6d4;
    }
    
    .practice-mode:hover {
      background: #0891b2;
    }
    
    .pvp-mode {
      background: #8b5cf6;
    }
    
    .pvp-mode:hover {
      background: #7c3aed;
    }
    
    .mode-icon {
      font-size: var(--font-lg);
    }
    
    .mode-text {
      font-size: var(--font-sm);
    }

    /* 연습모드에서 플레이어 2 숨기기 (레이아웃 유지) */
    .practice-mode-active .p2 {
      visibility: hidden !important;
    }
    
    .practice-mode-active .scores .p2 {
      visibility: hidden !important;
    }
    
    .practice-mode-active .combo-p2 {
      visibility: hidden !important;
    }
    
    /* 룰북 모달 스타일 */
    .rules-card {
      width: min(700px, 90vw);
      max-height: 85vh;
      background: var(--bg-secondary);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border);
      overflow: hidden;
      margin: auto;
    }
    
    .rules-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2xl) var(--space-3xl);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .rules-title {
      font-size: var(--font-3xl);
      font-weight: 800;
      margin: 0;
    }
    
    .rules-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      font-size: var(--font-lg);
      cursor: pointer;
      transition: all 0.3s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .rules-close:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }
    
    .rules-content {
      padding: var(--space-3xl);
      max-height: calc(85vh - 100px);
      overflow-y: auto;
    }
    
    .rules-section {
      margin-bottom: var(--space-3xl);
    }
    
    .rules-section h3 {
      font-size: var(--font-xl);
      font-weight: 700;
      color: var(--txt-primary);
      margin-bottom: var(--space-lg);
      border-bottom: 2px solid var(--border);
      padding-bottom: var(--space-sm);
    }
    
    .rules-section p {
      font-size: var(--font-base);
      line-height: 1.6;
      color: var(--txt-secondary);
      margin-bottom: var(--space-lg);
    }
    
    .venn-areas {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-xl) 0;
    }
    
    .area-item {
      display: flex;
      align-items: center;
      gap: var(--space-md);
      padding: var(--space-md);
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
    }
    
    .area-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    .area-color.only-a { background: #3b82f6; }
    .area-color.intersection { background: #10b981; }
    .area-color.only-b { background: #06b6d4; }
    .area-color.outside { background: #6b7280; }
    
    .area-text {
      font-size: var(--font-base);
      color: var(--txt-primary);
    }
    
    .interactive-venn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-md);
      margin: var(--space-lg) 0;
    }
    
    #rulesVennCanvas {
      border: 2px solid var(--border);
      border-radius: var(--radius-lg);
      cursor: pointer;
      margin: var(--space-sm) auto;
      display: block;
      max-width: 100%;
      height: auto;
    }
    
    .venn-instructions {
      text-align: center;
    }
    
    .venn-instructions p {
      font-size: var(--font-base);
      color: var(--txt-secondary);
      margin-bottom: var(--space-md);
    }
    
    .selected-areas {
      font-size: var(--font-lg);
      font-weight: 600;
      color: var(--accent);
      padding: var(--space-md) var(--space-xl);
      background: var(--bg-primary);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    
    .practice-problems {
      display: grid;
      gap: var(--space-lg);
    }
    
    .problem-item {
      padding: var(--space-lg);
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
    }
    
    .problem-item strong {
      color: var(--txt-primary);
      font-size: var(--font-lg);
    }
    
    .practice-controls {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
      margin-bottom: var(--space-md);
      flex-wrap: wrap;
    }
    
    .practice-btn {
      background: var(--bg-accent);
      color: var(--txt-white);
      border: none;
      padding: var(--space-sm) var(--space-xl);
      border-radius: var(--radius-sm);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    
    .practice-btn:hover {
      background: #059669;
      transform: translateY(-1px);
    }
    
    .practice-btn.active {
      background: #047857;
      box-shadow: 0 2px 8px rgba(4, 120, 87, 0.3);
    }
    
    .practice-question {
      font-size: var(--font-xl);
      font-weight: 700;
      color: var(--txt-primary);
      text-align: center;
      margin-bottom: var(--space-md);
      padding: var(--space-md);
      background: var(--bg-primary);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
    }
    
    .practice-result {
      margin-top: var(--space-lg);
      padding: var(--space-md) var(--space-xl);
      border-radius: var(--radius-sm);
      font-weight: 600;
      text-align: center;
      min-height: 20px;
    }
    
    .practice-result.correct {
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    }
    
    .practice-result.wrong {
      background: #fef2f2;
      color: #dc2626;
      border: 1px solid #fecaca;
    }
    
    .practice-result.empty {
      background: var(--bg-primary);
      color: var(--txt-secondary);
      border: 1px solid var(--border);
    }
    
    .region-meaning {
      font-size: var(--font-lg);
      font-weight: 700;
      color: var(--accent);
      text-align: center;
      margin-bottom: var(--space-lg);
      min-height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    /* 게임 컨트롤 버튼 */
    .game-controls {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin: 0;
      padding: 0;
    }
    
    .home-btn {
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      color: white;
      border: none;
      padding: var(--space-lg);
      border-radius: var(--radius-lg);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 70px;
      height: 70px;
      position: absolute;
      right: var(--space-lg);
      top: 150px;
      z-index: 10;
      touch-action: manipulation;
    }
    
    @media (max-width: 768px) {
      .home-btn {
        width: 60px;
        height: 60px;
        right: var(--space-md);
        top: 120px;
        padding: var(--space-md);
      }
    }
    
    @media (max-width: 480px) {
      .home-btn {
        width: 50px;
        height: 50px;
        right: var(--space-sm);
        top: 100px;
        padding: var(--space-sm);
        font-size: var(--font-sm);
      }
    }
    
    
    .home-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 12px rgba(251, 191, 36, 0.3);
    }
    
    .home-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-xs);
    }
    
    .home-icon {
      font-size: var(--font-lg);
      line-height: 1;
    }
    
    .home-text {
      font-size: var(--font-sm);
      line-height: 1;
    }
    
  </style>
</head>
<body>
  <!-- START OVERLAY -->
  <div class="overlay" id="start" role="dialog" aria-modal="true" aria-labelledby="start-title">
    <div class="card stack">
      <div class="center">
        <div class="title-container">
          <div class="title" id="start-title">🌐 SET MASTER</div>
          <button class="rules-btn" id="rulesBtn" title="벤다이어그램 학습">
            <span class="rules-icon">📚</span>
            <span class="rules-text">학습하기</span>
          </button>
        </div>
      </div>

      <div class="row">
        <label class="stack">
          <span class="lbl">전체집합: <b>N</b> 이하의 자연수</span>
          <input id="maxN" class="input" type="number" min="10" max="100" value="30" />
          <button class="outline" id="randomize">집합 A, B 랜덤으로 얻기</button>
        </label>

        <div class="stack">
          <span class="lbl">집합 A</span>
          <div class="seg" id="typeA">
            <button data-type="mul" class="active">배수</button>
            <button data-type="div">약수</button>
            <button data-type="prime">소수</button>
          </div>
          <select id="paramA" class="select"></select>
          <div class="hint" id="hintA"></div>
        </div>

        <div class="stack">
          <span class="lbl">집합 B</span>
          <div class="seg" id="typeB">
            <button data-type="mul" class="active">배수</button>
            <button data-type="div">약수</button>
            <button data-type="prime">소수</button>
          </div>
          <select id="paramB" class="select"></select>
          <div class="hint" id="hintB"></div>
        </div>
      </div>

      <div class="row">
        <label class="stack">
          <span class="lbl">게임 시간</span>
          <div class="seg" id="timeSeg">
            <button data-t="30">30초</button>
            <button data-t="60" class="active">60초</button>
            <button data-t="90">90초</button>
          </div>
        </label>
        <label class="stack">
          <span class="lbl">난이도</span>
          <div class="seg" id="modeSeg">
            <button data-m="union" class="active">Easy : A∪B에서만</button>
            <button data-m="any">Hard : 전체집합 U에서</button>
          </div>
        </label>
      </div>

      <div class="actions">
        <button class="mode-btn practice-mode" id="practiceMode">
          <span class="mode-icon">🏹</span>
          <span class="mode-text">연습 모드</span>
        </button>
        <button class="mode-btn pvp-mode" id="pvpMode">
          <span class="mode-icon"> ⚔️ </span>
          <span class="mode-text">PvP 모드</span>
        </button>
      </div>
      
      <footer class="footer">
        <div>행복한 수학, 함께 만들어요! 😊</div>
        <div>© 행복한윤쌤 | <a href="https://blog.naver.com/happy_yoonssam" target="_blank">https://blog.naver.com/happy_yoonssam</a></div>
      </footer>
    </div>
  </div>

  <!-- END OVERLAY -->
  <div class="overlay" id="end" style="display:none">
    <div class="card stack end">
      <div class="center">
        <div class="title">게임 종료!</div>
        <div id="winMsg" class="lg" style="margin:6px 0 4px"></div>
        <div id="final" class="muted"></div>
      </div>
      <div class="actions" style="justify-content:center">
        <button class="outline" id="again">다시 하기</button>
        <button class="primary" id="settings">첫 화면으로</button>
      </div>
    </div>
  </div>

  <!-- VENN DIAGRAM CHALLENGE -->
  <div class="venn-modal" id="vennModal" style="display:none">
    <div class="venn-card">
      <div class="venn-title" id="vennTitle">1플레이어 콤보 챌린지</div>
      
      <div class="venn-question">
        <h2 id="vennQ">A ∩ B</h2>
        <div class="venn-timer">
          <div class="venn-timer-bar">
            <div id="vennTimerBar" class="venn-timer-fill"></div>
          </div>
        </div>
      </div>

      <canvas id="vennCanvas" class="venn-svg" width="400" height="320"></canvas>

      <div id="vennResult" style="display:none"></div>

      <button class="venn-btn check" id="vennCheck">정답 제출</button>
      <button class="venn-btn next" id="vennNext" style="display:none">계속하기</button>
    </div>
  </div>

  <!-- RULES MODAL -->
  <div class="overlay" id="rulesModal" style="display:none">
    <div class="rules-card">
      <div class="rules-header">
        <h2 class="rules-title">📚 벤다이어그램 학습</h2>
        <button class="rules-close" id="rulesClose">✕</button>
      </div>
      
      <div class="rules-content">
        <div class="rules-section">
          <h3>🎯 기본 개념</h3>
          <p>벤다이어그램은 집합의 관계를 시각적으로 표현하는 도구입니다. 두 개의 원으로 A와 B 집합을 나타내고, 겹치는 부분과 겹치지 않는 부분을 구분합니다.</p>
        </div>
        
        <div class="rules-section">
          <h3>🔍 영역별 의미</h3>
          <div class="venn-areas">
            <div class="area-item">
              <div class="area-color only-a"></div>
              <div class="area-text">
                <strong>A-B</strong> : A에만 속함
              </div>
            </div>
            <div class="area-item">
              <div class="area-color intersection"></div>
              <div class="area-text">
                <strong>A∩B</strong> : A와 B모두에 속함
              </div>
            </div>
            <div class="area-item">
              <div class="area-color only-b"></div>
              <div class="area-text">
                <strong>B-A</strong> : B에만 속함
              </div>
            </div>
            <div class="area-item">
              <div class="area-color outside"></div>
              <div class="area-text">
                <strong>(A∪B)ᶜ</strong> : A와 B에 모두 속하지 않음
              </div>
            </div>
          </div>
        </div>
        
        <div class="rules-section">
          <h3>🎮 인터랙티브 학습</h3>
          <p>실제 챌린지에 등장하는 문제를 연습해보세요! 벤다이어그램을 클릭해서 정답을 선택하세요.</p>
          <div class="interactive-venn">
            <div class="practice-controls">
              <button class="practice-btn" id="practiceEasy">기본 문제</button>
              <button class="practice-btn" id="practiceHard">하드 문제</button>
              <button class="practice-btn" id="practiceNext">다음 문제</button>
            </div>
            <div class="practice-question" id="practiceQuestion">문제를 선택하세요</div>
            <canvas id="rulesVennCanvas" width="500" height="400"></canvas>
            <div class="venn-instructions">
              <div class="region-meaning" id="regionMeaning"></div>
              <div class="practice-result" id="practiceResult"></div>
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <div class="feedback" id="fb"></div>

  <div class="info glass">
    <div class="scores">
      <div class="score p1">
        <div class="label">플레이어 1</div>
        <div class="val" id="s1">0</div>
      </div>
      <div class="combo-display combo-p1" id="combo1"></div>
    </div>
    <div class="timer-wrap">
      <div class="game-title">🌐 SET MASTER</div>
      <div class="bar"><div id="barInner"></div></div>
    </div>
    <div class="scores">
      <div class="combo-display combo-p2" id="combo2"></div>
      <div class="score p2">
        <div class="label">플레이어 2</div>
        <div class="val" id="s2">0</div>
      </div>
    </div>
  </div>

  <div class="sets">
    <div class="setbox">
      <div class="desc" id="aDesc">–</div>
    </div>
    <div class="setbox">
      <div class="desc" id="bDesc">–</div>
    </div>
  </div>
  
  <!-- 메인화면 돌아가기 버튼 -->
  <button class="home-btn" id="homeBtn" title="메인화면으로 돌아가기">
    <div class="home-content">
      <div class="home-icon">🏠</div>
      <div class="home-text">메인</div>
    </div>
  </button>

  <div class="number">
    <div class="num" id="num">?</div>
  </div>

  <div class="controls">
    <div class="col p1">
      <div class="player">플레이어 1</div>
      <div class="buttons">
        <button class="btn" data-p="1" data-a="A_MINUS_B" aria-label="A에서 B를 뺀 차집합">A−B<br><span class="kbd">Q</span></button>
        <button class="btn" data-p="1" data-a="AB" aria-label="A와 B의 교집합">A∩B<br><span class="kbd">W</span></button>
        <button class="btn" data-p="1" data-a="B_MINUS_A" aria-label="B에서 A를 뺀 차집합">B−A<br><span class="kbd">E</span></button>
        <button class="btn" data-p="1" data-a="NONE" id="p1-none" style="display:none" aria-label="A와 B의 합집합의 여집합">(A∪B)ᶜ<br><span class="kbd">R</span></button>
      </div>
    </div>
    <div class="col p2">
      <div class="player">플레이어 2</div>
      <div class="buttons">
        <button class="btn" data-p="2" data-a="A_MINUS_B" aria-label="A에서 B를 뺀 차집합">A−B<br><span class="kbd">U</span></button>
        <button class="btn" data-p="2" data-a="AB" aria-label="A와 B의 교집합">A∩B<br><span class="kbd">I</span></button>
        <button class="btn" data-p="2" data-a="B_MINUS_A" aria-label="B에서 A를 뺀 차집합">B−A<br><span class="kbd">O</span></button>
        <button class="btn" data-p="2" data-a="NONE" id="p2-none" style="display:none" aria-label="A와 B의 합집합의 여집합">(A∪B)ᶜ<br><span class="kbd">P</span></button>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function(){
    'use strict';

    const el = (id)=>document.getElementById(id);
    const isPrime = (n)=>{
      if(n < 2) return false; if(n%2===0) return n===2; if(n%3===0) return n===3;
      for(let i=5;i*i<=n;i+=6){ if(n%i===0 || n%(i+2)===0) return false; }
      return true;
    };
    const isSquare = (n)=>{ const r = Math.floor(Math.sqrt(n)); return r*r === n; };
    const compositeNonSquaresUpTo = (N)=>{
      const arr=[]; 
      for(let i=4;i<=N;i++){ 
        if(!isPrime(i) && !isSquare(i)) {
          arr.push(i); 
        } 
      } 
      return arr;
    };

    const state = {
      N: 30,
      setA: { type:'mul', param: 2 },
      setB: { type:'mul', param: 3 },
      difficulty: 'union', // 'union' = Easy, 'any' = Hard
      time: 60,
      timeLeft: 60,
      playing: false,
      answered: false,
      num: 1,
      s: [0,0],
      combo: [0,0],
      timer: null,
      gameMode: 'pvp', // 'pvp' or 'practice'
      buttonOrder: { p1: ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'], p2: ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'] }, // 버튼 순서 저장
      randomized: { p1: false, p2: false }, // 하드모드 진입 시 랜덤화 여부
      disabledPlayers: [], // 비활성화된 플레이어 목록
      disableTimers: {} // 각 플레이어의 비활성화 타이머
    };

    // Venn diagram problems by difficulty level
    const vennProblemsEasy = [
      { question: "A ∩ B", answer: ["intersection"], description: "A와 B의 교집합" },
      { question: "A ∪ B", answer: ["onlyA", "intersection", "onlyB"], description: "A와 B의 합집합" },
      { question: "A - B", answer: ["onlyA"], description: "A에서 B를 뺀 차집합" },
      { question: "B - A", answer: ["onlyB"], description: "B에서 A를 뺀 차집합" },
      { question: "Aᶜ", answer: ["onlyB", "outside"], description: "A의 여집합" },
      { question: "Bᶜ", answer: ["onlyA", "outside"], description: "B의 여집합" },
      { question: "A ∩ Bᶜ", answer: ["onlyA"], description: "A와 B의 여집합의 교집합" },
      { question: "Aᶜ ∩ B", answer: ["onlyB"], description: "A의 여집합과 B의 교집합" },
      { question: "(A ∩ B)ᶜ", answer: ["onlyA", "onlyB", "outside"], description: "A와 B의 교집합의 여집합" },
      { question: "(A ∪ B)ᶜ", answer: ["outside"], description: "A와 B의 합집합의 여집합" },
    ];

    const vennProblemsHard = [
      { question: "(A∪B)-(A∩B)", answer: ["onlyA", "onlyB"], description: "A와 B 중 하나에만 속하는 원소들" },
      { question: "Aᶜ∩Bᶜ", answer: ["outside"], description: "A와 B 모두에 속하지 않는 원소들" },
      { question: "(A-B)∪(B-A)", answer: ["onlyA", "onlyB"], description: "A와 B 중 하나에만 속하는 원소들" },
      { question: "Aᶜ∪Bᶜ", answer: ["onlyA", "onlyB", "outside"], description: "A에 속하지 않거나 B에 속하지 않는 원소들" },
      { question: "(A∪B)∩(A∩B)ᶜ", answer: ["onlyA", "onlyB"], description: "A와 B 중 하나에만 속하는 원소들" },
      { question: "Aᶜ∩(A∪B)", answer: ["onlyB"], description: "A의 여집합과 A와 B의 합집합의 교집합" },
      { question: "Bᶜ∩(A∪B)", answer: ["onlyA"], description: "B의 여집합과 A와 B의 합집합의 교집합" },
    ];

    const vennState = {
      currentProblem: null,
      selectedRegions: [],
      showResult: false,
      player: 1,
      timeLeft: 10,
      timer: null,
    };

    const s1 = el('s1'), s2 = el('s2');
    const combo1 = el('combo1'), combo2 = el('combo2');
    const bar = el('barInner');
    const aDesc = el('aDesc');
    const bDesc = el('bDesc');
    const numEl = el('num');
    const fb = el('fb');
    const startOv = el('start');
    const endOv = el('end');
    const winMsg = el('winMsg');
    const final = el('final');
    const maxNInput = el('maxN');
    const typeA = el('typeA');
    const typeB = el('typeB');
    const paramA = el('paramA');
    const paramB = el('paramB');
    const hintA = el('hintA');
    const hintB = el('hintB');

    const vennModal = el('vennModal');
    const vennQ = el('vennQ');
    const vennResult = el('vennResult');
    const vennCheck = el('vennCheck');
    const vennNext = el('vennNext');
    const vennTimerBar = el('vennTimerBar');
    const p1None = el('p1-none');
    const p2None = el('p2-none');

    function buildParamOptions(setKey){
      const type = state[setKey].type;
      const sel = setKey==='setA'? paramA : paramB;
      sel.innerHTML=''; sel.disabled=false; sel.style.display='';

      let values=[]; let labelFn=(v)=>v+'';
      if(type==='mul'){
        const upTo = Math.min(10, state.N);
        values = Array.from({length: Math.max(0, upTo-1)}, (_,i)=> i+2);
        labelFn = (v)=> `${v}의 배수`;
      } else if(type==='div'){
        const comps = compositeNonSquaresUpTo(state.N);
        values = comps; labelFn = (v)=> `${v}의 약수`;
      } else if(type==='prime'){
        sel.disabled = true; sel.style.display='none';
      }

      for(const v of values){ const o=document.createElement('option'); o.value=v; o.textContent=labelFn(v); sel.appendChild(o); }

      if(type==='mul'){
        state[setKey].param = parseInt(sel.value || 2,10);
      } else if(type==='div'){
        const first = values[0] || 6;
        state[setKey].param = parseInt(sel.value || first,10);
      } else if(type==='prime'){
        state[setKey].param = null;
      }

      updateHints(); updateSetDesc();
    }

    function updateHints(){
      const a = state.setA, b = state.setB;
      hintA.textContent = a.type==='mul' ? `${a.param}의 배수 집합`
        : a.type==='div' ? `${a.param}의 약수 집합`
        : `소수 집합`;
      hintB.textContent = b.type==='mul' ? `${b.param}의 배수 집합`
        : b.type==='div' ? `${b.param}의 약수 집합`
        : `소수 집합`;
    }

    function updateSetDesc(){
      const a = state.setA, b = state.setB;
      aDesc.textContent = a.type==='mul' ? `A={x|x는 ${a.param}의 배수}`
        : a.type==='div' ? `A={x|x는 ${a.param}의 약수}`
        : `A={x|x는 소수}`;
      bDesc.textContent = b.type==='mul' ? `B={x|x는 ${b.param}의 배수}`
        : b.type==='div' ? `B={x|x는 ${b.param}의 약수}`
        : `B={x|x는 소수}`;
    }

    function inSet(n, set){
      if(set.type==='mul') return n % set.param === 0;
      if(set.type==='div') return set.param % n === 0;
      if(set.type==='prime') return isPrime(n);
      return false;
    }

    function correctFor(n){
      const inA = inSet(n, state.setA);
      const inB = inSet(n, state.setB);
      if(inA && inB) return 'AB';
      if(inA && !inB) return 'A_MINUS_B';
      if(!inA && inB) return 'B_MINUS_A';
      return 'NONE';
    }

    function showFB(text, ok=true){
      fb.textContent = text;
      fb.className = `feedback ${ok? 'ok':'bad'} show`;
      setTimeout(()=> fb.classList.remove('show'), 650);
    }
    

    function updateButtonLayout(){
      const isHardMode = state.difficulty === 'any';
      
      // 4번째 버튼 표시/숨김
      if(p1None) p1None.style.display = isHardMode ? 'block' : 'none';
      if(p2None) p2None.style.display = isHardMode ? 'block' : 'none';
      
      // 버튼 레이아웃 업데이트
      const p1Buttons = document.querySelector('.p1 .buttons');
      const p2Buttons = document.querySelector('.p2 .buttons');
      
      if(p1Buttons) {
        p1Buttons.className = isHardMode ? 'buttons any-mode' : 'buttons';
      }
      if(p2Buttons) {
        p2Buttons.className = isHardMode ? 'buttons any-mode' : 'buttons';
      }
    }

    // 콤보 표시 업데이트 함수
    function updateComboDisplay(comboElement, comboValue, playerClass) {
      if(comboValue > 0) {
        const level = Math.min(Math.ceil(comboValue / 3), 5);
        const newClassName = `combo-display ${playerClass} combo-level-${level}`;
        
        // 클래스가 변경된 경우에만 HTML 재생성
        if(comboElement.className !== newClassName) {
          let fireEmojis = '🔥';
          if(comboValue >= 4 && comboValue <= 6) {
            fireEmojis = '🔥🔥';
          } else if(comboValue >= 7) {
            fireEmojis = '🔥🔥🔥';
          }
          
          comboElement.className = newClassName;
          comboElement.innerHTML = `<div class="fire">${fireEmojis}</div><div class="text">${comboValue}연속</div>`;
        } else {
          // 클래스가 같으면 텍스트만 업데이트
          const textElement = comboElement.querySelector('.text');
          if(textElement) {
            textElement.textContent = `${comboValue}연속`;
          }
        }
      } else {
        comboElement.className = `combo-display ${playerClass}`;
        comboElement.innerHTML = '';
      }
    }

    // 점수 업데이트 함수
    function updateScores() {
      s1.textContent = state.s[0];
      s2.textContent = state.s[1];
    }

    // 타이머 바 업데이트 함수
    function updateTimerBar() {
      const ratio = Math.max(0, state.timeLeft) / state.time;
      bar.style.transform = `scaleX(${ratio})`;
    }

    // 통합된 HUD 업데이트 함수
    function updateHUD(){
      updateScores();
      updateComboDisplay(combo1, state.combo[0], 'combo-p1');
      updateComboDisplay(combo2, state.combo[1], 'combo-p2');
      updateTimerBar();
      updateSetDesc();
      updateButtonLayout();
      updateButtonTexts();
      updateGameModeUI();
    }
    
    // 플레이어별 버튼 텍스트 업데이트
    function updatePlayerButtons(playerNum) {
      const buttons = document.querySelectorAll(`.p${playerNum} .btn`);
      const score = state.s[playerNum - 1];
      const isHardMode = score >= 10;
      const playerKey = `p${playerNum}`;
      
      // 하드 모드 진입 시 한 번만 집합 연산 랜덤화
      if(isHardMode && !state.randomized[playerKey]) {
        randomizeSetOperations(playerKey);
        state.randomized[playerKey] = true; // 랜덤화 완료 표시
      }
      
      // 이지 모드로 돌아가면 랜덤화 상태 초기화
      if(!isHardMode && state.randomized[playerKey]) {
        state.randomized[playerKey] = false;
      }
      
      buttons.forEach((btn) => {
        const answer = btn.dataset.a;
        btn.innerHTML = getButtonText(answer, score, playerNum);
      });
    }

    // 통합된 버튼 텍스트 업데이트
    function updateButtonTexts(){
      updatePlayerButtons(1);
      
      // 플레이어 2 버튼 업데이트 (PvP모드에서만)
      if(state.gameMode === 'pvp'){
        updatePlayerButtons(2);
      }
    }
    
    function getButtonText(answer, score, player = 1){
      const isHardMode = score >= 10;
      const keys = player === 1 ? ['Q', 'W', 'E', 'R'] : ['U', 'I', 'O', 'P'];
      
      // 버튼의 물리적 위치에 따라 키 결정 (항상 Q,W,E,R 또는 U,I,O,P 순서)
      const playerClass = player === 1 ? '.p1' : '.p2';
      const buttonsContainer = document.querySelector(`${playerClass} .buttons`);
      if (!buttonsContainer) return `A∩B<br><span class="kbd">W</span>`;
      
      const buttons = Array.from(buttonsContainer.querySelectorAll('.btn'));
      const buttonIndex = buttons.findIndex(btn => btn.dataset.a === answer);
      const key = keys[buttonIndex] || keys[0];
      
      // 집합 연산 표시 (하드모드에서는 더 복잡한 표기법)
      switch(answer){
        case 'A_MINUS_B':
          return isHardMode ? `A∩Bᶜ<br><span class="kbd">${key}</span>` : `A−B<br><span class="kbd">${key}</span>`;
        case 'AB':
          return `A∩B<br><span class="kbd">${key}</span>`;
        case 'B_MINUS_A':
          return isHardMode ? `Aᶜ∩B<br><span class="kbd">${key}</span>` : `B−A<br><span class="kbd">${key}</span>`;
        case 'NONE':
          return isHardMode ? `Aᶜ∩Bᶜ<br><span class="kbd">${key}</span>` : `(A∪B)ᶜ<br><span class="kbd">${key}</span>`;
        default:
          return `A∩B<br><span class="kbd">${key}</span>`;
      }
    }
    
    function updateGameModeUI(){
      const isPractice = state.gameMode === 'practice';
      const p2Section = document.querySelector('.p2');
      const p2Score = document.querySelector('.scores .p2');
      
      if(isPractice){
        // 연습모드: body에 클래스 추가하여 CSS로 숨기기
        document.body.classList.add('practice-mode-active');
        
        // 플레이어 1은 그대로 유지 (플레이어 1)
        const p1Label = document.querySelector('.p1 .player');
        if(p1Label) p1Label.textContent = '플레이어 1';
        
        // 게임 제목은 SET MASTER로 유지
        const gameTitle = document.querySelector('.game-title');
        if(gameTitle) gameTitle.textContent = '🌐 SET MASTER';
      } else {
        // PvP모드: 클래스 제거하고 모든 섹션 표시
        document.body.classList.remove('practice-mode-active');
        
        if(p2Section) p2Section.style.visibility = 'visible';
        if(p2Score) p2Score.style.visibility = 'visible';
        
        // 플레이어 1을 원래대로
        const p1Label = document.querySelector('.p1 .player');
        if(p1Label) p1Label.textContent = '플레이어 1';
        
        // 게임 제목 원래대로
        const gameTitle = document.querySelector('.game-title');
        if(gameTitle) gameTitle.textContent = '🌐 SET MASTER';
      }
    }

    // 플레이어 버튼 비활성화/활성화 함수들
    function disablePlayerButtons(player) {
      // 해당 플레이어의 모든 버튼 비활성화
      const buttons = document.querySelectorAll(`.p${player} .btn`);
      buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
      });
      
      // 비활성화 상태에 추가
      if (!state.disabledPlayers.includes(player)) {
        state.disabledPlayers.push(player);
      }
    }

    function enablePlayerButtons(player) {
      // 해당 플레이어의 모든 버튼 활성화
      const buttons = document.querySelectorAll(`.p${player} .btn`);
      buttons.forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      });
      
      // 비활성화 상태에서 제거
      state.disabledPlayers = state.disabledPlayers.filter(p => p !== player);
    }

    function disablePlayerTemporarily(player, duration = 500) {
      // 기존 타이머가 있으면 정리
      if (state.disableTimers[player]) {
        clearTimeout(state.disableTimers[player]);
      }
      
      // 버튼 비활성화
      disablePlayerButtons(player);
      
      // 지정된 시간 후 자동 활성화
      state.disableTimers[player] = setTimeout(() => {
        enablePlayerButtons(player);
        delete state.disableTimers[player];
      }, duration);
    }

    function startTimer(){
      clearInterval(state.timer);
      state.timer = setInterval(()=>{
        state.timeLeft -= 0.25;
        updateHUD();
        if(state.timeLeft<=0){ endGame(); }
      }, 250); // 0.25초마다 업데이트
    }

    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
    
    // 배열을 랜덤으로 섞는 함수 (Fisher-Yates shuffle)
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }
    
    // 하드 모드에서 버튼 순서를 랜덤으로 설정하는 함수
    function randomizeButtonOrder(player) {
      const answers = ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'];
      state.buttonOrder[player] = shuffleArray(answers);
      
      // 실제 버튼 순서 변경
      reorderButtons(player);
    }
    
    // 키 순서는 유지하고 집합 연산만 랜덤화하는 함수
    function randomizeSetOperations(player) {
      const answers = ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'];
      state.buttonOrder[player] = shuffleArray(answers);
      
      // 실제 버튼 순서 변경 (키 순서는 유지하고 집합 연산만 랜덤화)
      reorderButtons(player);
    }
    
    // 버튼의 실제 순서를 변경하는 함수 (키 순서는 유지하고 집합 연산만 랜덤화)
    function reorderButtons(player) {
      const playerClass = player === 'p1' ? '.p1' : '.p2';
      const buttonsContainer = document.querySelector(`${playerClass} .buttons`);
      if (!buttonsContainer) return;
      
      const buttons = Array.from(buttonsContainer.querySelectorAll('.btn'));
      const orderedButtons = [];
      
      // 키 순서는 유지하고 집합 연산만 랜덤화된 순서로 재배치
      state.buttonOrder[player].forEach(answer => {
        const button = buttons.find(btn => btn.dataset.a === answer);
        if (button) {
          orderedButtons.push(button);
        }
      });
      
      // DOM에서 버튼들을 제거하고 새로운 순서로 다시 추가
      buttons.forEach(btn => btn.remove());
      orderedButtons.forEach(btn => buttonsContainer.appendChild(btn));
    }

    function pickNumber(){
      let n;
      if(state.difficulty==='union'){
        let tries=0;
        do { n = randInt(1, state.N); tries++; if(tries>500){ break; } }
        while(!inSet(n, state.setA) && !inSet(n, state.setB));
      } else {
        n = randInt(1, state.N);
      }
      state.num = n; numEl.textContent = n; state.answered=false;
    }

    function startGame(){
      state.N = Math.max(10, Math.min(100, parseInt(maxNInput.value||30,10)));
      state.s = [0,0]; 
      state.combo = [0,0];
      state.timeLeft = state.time; 
      state.playing = true; 
      state.answered=false;
      
      // 비활성화 상태 초기화
      state.disabledPlayers = [];
      Object.values(state.disableTimers).forEach(timer => clearTimeout(timer));
      state.disableTimers = {};
      
      // 모든 버튼 활성화
      enablePlayerButtons(1);
      enablePlayerButtons(2);
      
      // 버튼 순서 초기화
      state.buttonOrder.p1 = ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'];
      state.buttonOrder.p2 = ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'];
      
      // 랜덤화 상태 초기화
      state.randomized.p1 = false;
      state.randomized.p2 = false;
      
      // 버튼 순서를 원래대로 재배치
      reorderButtons('p1');
      reorderButtons('p2');
      
      startOv.style.display='none'; 
      endOv.style.display='none';
      updateHUD(); 
      pickNumber(); 
      startTimer();
    }

    function endGame(){
      state.playing=false; 
      clearInterval(state.timer);
      
      // 모든 비활성화 타이머 정리
      Object.values(state.disableTimers).forEach(timer => clearTimeout(timer));
      state.disableTimers = {};
      state.disabledPlayers = [];
      
      // 모든 버튼 활성화
      enablePlayerButtons(1);
      enablePlayerButtons(2);
      
      const [a,b] = state.s;
      
      if(state.gameMode === 'practice'){
        winMsg.textContent = '🎉 연습 완료!';
        winMsg.style.color = 'var(--p1)';
        final.innerHTML = `총 점수: <b>${a}</b>점`;
      } else {
        if(a>b){ winMsg.textContent = '🎉 플레이어 1 승리!'; winMsg.style.color = 'var(--p1)'; }
        else if(b>a){ winMsg.textContent = '🎉 플레이어 2 승리!'; winMsg.style.color = 'var(--p2)'; }
        else { winMsg.textContent = '🤝 무승부!'; winMsg.style.color = 'var(--accent)'; }
        final.innerHTML = `플레이어 1: <b>${a}</b>점 &nbsp;·&nbsp; 플레이어 2: <b>${b}</b>점`;
      }
      
      endOv.style.display='flex';
    }

    function startVennTimer() {
      vennState.timeLeft = 10;
      updateVennTimer();
      
      vennState.timer = setInterval(() => {
        vennState.timeLeft -= 0.2;
        updateVennTimer();
        
        if (vennState.timeLeft <= 0) {
          clearInterval(vennState.timer);
          // 시간 초과 시 자동으로 정답 체크
          checkVennAnswer();
        }
      }, 200); // 0.2초마다 업데이트
    }

    function updateVennTimer() {
      const ratio = Math.max(0, vennState.timeLeft) / 10;
      vennTimerBar.style.width = `${ratio * 100}%`;
    }

    function showVennChallenge(player){
      vennState.player = player;
      vennState.selectedRegions = [];
      vennState.showResult = false;
      
      // 콤보 수준에 따라 문제 난이도 결정
      const currentCombo = state.combo[player-1];
      const problems = currentCombo >= 4 ? vennProblemsHard : vennProblemsEasy;
      const problem = problems[randInt(0, problems.length-1)];
      vennState.currentProblem = problem;
      
      const vennTitle = el('vennTitle');
      const difficulty = currentCombo >= 4 ? ' HARD' : '' ;
      
      if(state.gameMode === 'practice'){
        vennTitle.textContent = `플레이어 1 콤보 챌린지 🔥${difficulty}`;
        vennTitle.style.color = 'var(--p1)';
      } else {
        vennTitle.textContent = `${player}플레이어 콤보 챌린지 🔥${difficulty}`;
        vennTitle.style.color = player === 1 ? 'var(--p1)' : 'var(--p2)';
      }
      
      vennQ.textContent = problem.question;
      
      resetVennRegions();
      vennResult.style.display = 'none';
      vennCheck.style.display = 'block';
      vennNext.style.display = 'none';
      
      clearInterval(state.timer);
      vennModal.style.display = 'flex';
      
      // 캔버스 크기 조정
      const canvas = el('vennCanvas');
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      const aspectRatio = 400 / 320;
      const newWidth = Math.min(containerWidth * 0.8, 400);
      const newHeight = newWidth / aspectRatio;
      
      canvas.width = newWidth;
      canvas.height = newHeight;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      
      // 초기 다이어그램 그리기
      drawVennDiagram();
      
      // 챌린지 타이머 시작
      startVennTimer();
    }

    // 통합된 벤다이어그램 시스템
    const VennDiagram = {
      // 게임용 벤다이어그램 설정
      game: {
        canvas: el('vennCanvas'),
        geometry: { U: { x: 40, y: 40, w: 320, h: 240, r: 8 }, A: { x: 160, y: 160, r: 80 }, B: { x: 240, y: 160, r: 80 } }
      },
      // 룰북용 벤다이어그램 설정
      rules: {
        canvas: null,
        geometry: { U: { x: 50, y: 50, w: 400, h: 300, r: 8 }, A: { x: 200, y: 200, r: 80 }, B: { x: 300, y: 200, r: 80 } }
      },
      
      // 반응형 기하학 설정 업데이트
      updateGeometry(type = 'game') {
        const config = this[type];
        if (!config.canvas) return;
        
        const canvas = config.canvas;
        const rect = canvas.getBoundingClientRect();
        
        if (type === 'game') {
          const scale = Math.min(rect.width / 400, rect.height / 320);
          config.geometry = {
            U: { x: 40 * scale, y: 40 * scale, w: 320 * scale, h: 240 * scale, r: 8 },
            A: { x: 160 * scale, y: 160 * scale, r: 80 * scale },
            B: { x: 240 * scale, y: 160 * scale, r: 80 * scale }
          };
        } else {
          // 룰북용: 캔버스 크기에 맞춰 비례적으로 조정
          const scaleX = rect.width / 500;
          const scaleY = rect.height / 400;
          const scale = Math.min(scaleX, scaleY);
          
          config.geometry = {
            U: { x: 50 * scale, y: 50 * scale, w: 400 * scale, h: 300 * scale, r: 8 },
            A: { x: 200 * scale, y: 200 * scale, r: 80 * scale },
            B: { x: 300 * scale, y: 200 * scale, r: 80 * scale }
          };
        }
      },

      // 통합된 그리기 함수
      draw(type = 'game', selectedRegions = [], showResult = false, answerRegions = []) {
        const config = this[type];
        if (!config.canvas) return;
        
        // 반응형 기하학 업데이트
        this.updateGeometry(type);
        
        const ctx = config.canvas.getContext('2d');
        const geom = config.geometry;
        
        ctx.clearRect(0, 0, config.canvas.width, config.canvas.height);
        
        // Universal set background
        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
        
        // Draw selected regions
        selectedRegions.forEach(region => {
          this.drawRegion(type, region, '#2563eb', 1.0);
        });
        
        // Draw answer regions if showing result
        if(showResult) {
          answerRegions.forEach(region => {
            this.drawRegion(type, region, '#059669', 1.0);
          });
        }
        
        // Draw borders
        ctx.strokeStyle = '#64748b';
        ctx.lineWidth = 2;
        ctx.strokeRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
        
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = type === 'rules' ? 4 : 3;
        ctx.beginPath();
        ctx.arc(geom.A.x, geom.A.y, geom.A.r, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = type === 'rules' ? 4 : 3;
        ctx.beginPath();
        ctx.arc(geom.B.x, geom.B.y, geom.B.r, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw labels
        ctx.fillStyle = '#000000';
        ctx.font = type === 'rules' ? 'bold 28px system-ui' : 'bold 24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('A', geom.A.x - (type === 'rules' ? 30 : 20), geom.A.y + 8);
        ctx.fillText('B', geom.B.x + (type === 'rules' ? 30 : 20), geom.B.y + 8);
        
        ctx.fillStyle = '#000000';
        ctx.font = type === 'rules' ? 'bold 20px system-ui' : 'bold 20px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('U', geom.U.x + 10, geom.U.y + 25);
      },

      // 통합된 영역 그리기 함수
      drawRegion(type = 'game', region, color, opacity) {
        const config = this[type];
        const ctx = config.canvas.getContext('2d');
        const geom = config.geometry;
        
        const offCanvas = document.createElement('canvas');
        offCanvas.width = config.canvas.width;
        offCanvas.height = config.canvas.height;
        const offCtx = offCanvas.getContext('2d');
        
        offCtx.fillStyle = color;
        offCtx.globalAlpha = 1.0;
        
        switch(region) {
          case 'outside':
            offCtx.fillRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
            offCtx.globalCompositeOperation = 'destination-out';
            offCtx.beginPath();
            offCtx.arc(geom.A.x, geom.A.y, geom.A.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.beginPath();
            offCtx.arc(geom.B.x, geom.B.y, geom.B.r, 0, Math.PI * 2);
            offCtx.fill();
            break;
          case 'onlyA':
            offCtx.beginPath();
            offCtx.arc(geom.A.x, geom.A.y, geom.A.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-out';
            offCtx.beginPath();
            offCtx.arc(geom.B.x, geom.B.y, geom.B.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-in';
            offCtx.fillRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
            break;
          case 'onlyB':
            offCtx.beginPath();
            offCtx.arc(geom.B.x, geom.B.y, geom.B.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-out';
            offCtx.beginPath();
            offCtx.arc(geom.A.x, geom.A.y, geom.A.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-in';
            offCtx.fillRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
            break;
          case 'intersection':
            offCtx.beginPath();
            offCtx.arc(geom.A.x, geom.A.y, geom.A.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-in';
            offCtx.beginPath();
            offCtx.arc(geom.B.x, geom.B.y, geom.B.r, 0, Math.PI * 2);
            offCtx.fill();
            offCtx.globalCompositeOperation = 'destination-in';
            offCtx.fillRect(geom.U.x, geom.U.y, geom.U.w, geom.U.h);
            break;
        }
        
        ctx.drawImage(offCanvas, 0, 0);
      },

      // 영역 클릭 감지
      getRegionAtPoint(type = 'game', x, y) {
        const geom = this[type].geometry;
        const inA = Math.sqrt((x - geom.A.x) ** 2 + (y - geom.A.y) ** 2) <= geom.A.r;
        const inB = Math.sqrt((x - geom.B.x) ** 2 + (y - geom.B.y) ** 2) <= geom.B.r;
        const inU = x >= geom.U.x && x <= geom.U.x + geom.U.w && 
                    y >= geom.U.y && y <= geom.U.y + geom.U.h;
        
        if (!inU) return null;
        if (inA && inB) return 'intersection';
        if (inA) return 'onlyA';
        if (inB) return 'onlyB';
        return 'outside';
      }
    };

    // 기존 함수들을 새로운 시스템으로 대체
    function drawVennDiagram() {
      VennDiagram.draw('game', vennState.selectedRegions, vennState.showResult, vennState.currentProblem?.answer || []);
    }

    function drawVennRegion(region, color, opacity) {
      VennDiagram.drawRegion('game', region, color, opacity);
    }

    function resetVennRegions(){
      vennState.selectedRegions = [];
      drawVennDiagram();
    }

    function toggleVennRegion(region){
      if(vennState.showResult) return;
      
      if(vennState.selectedRegions.includes(region)){
        vennState.selectedRegions = vennState.selectedRegions.filter(r => r !== region);
      } else {
        vennState.selectedRegions.push(region);
      }
      
      drawVennDiagram();
    }

    function checkVennAnswer(){
      // 타이머 정리
      clearInterval(vennState.timer);
      
      const selected = [...vennState.selectedRegions].sort();
      const correct = [...vennState.currentProblem.answer].sort();
      const isCorrect = JSON.stringify(selected) === JSON.stringify(correct);
      
      vennState.showResult = true;
      
      // 이전 선택 영역 지우고 정답 영역만 표시
      vennState.selectedRegions = [];
      drawVennDiagram();
      
      if(isCorrect){
        vennResult.className = 'venn-result correct';
        vennResult.innerHTML = '<div style="font-size:1.5rem;font-weight:800">✓ 정답입니다!</div>';
      } else {
        vennResult.className = 'venn-result wrong';
        vennResult.innerHTML = '<div style="font-size:1.5rem;font-weight:800">✗ 틀렸습니다</div>';
        state.combo[vennState.player-1] = 0;
      }
      
      vennResult.style.display = 'block';
      vennCheck.style.display = 'none';
      vennNext.style.display = 'block';
    }

    function closeVennChallenge(){
      // 타이머 정리
      clearInterval(vennState.timer);
      
      vennModal.style.display = 'none';
      if(state.playing){
        startTimer();
        pickNumber();
      }
      updateHUD();
    }

    // 통합된 클릭 이벤트 처리
    vennCanvas.addEventListener('click', (e) => {
      if(vennState.showResult) return;
      
      const rect = vennCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (vennCanvas.width / rect.width);
      const y = (e.clientY - rect.top) * (vennCanvas.height / rect.height);
      
      const region = VennDiagram.getRegionAtPoint('game', x, y);
      if (region) {
        toggleVennRegion(region);
      }
    });


    function handleAnswer(player, ans){
      if(!state.playing || state.answered) return;
      
      // 비활성화된 플레이어는 무시
      if(state.disabledPlayers.includes(player)) return;
      
      // 연습모드에서는 플레이어 1만 답변 가능
      if(state.gameMode === 'practice' && player !== 1) return;
      
      state.answered = true;
      const corr = correctFor(state.num);
      const ok = (ans === corr);
      
      if(ok){
        // 4콤보부터는 2점, 그 외에는 1점
        const currentCombo = state.combo[player-1];
        const baseScore = currentCombo >= 4 ? 2 : 1;
        
        state.s[player-1] += baseScore;
        state.combo[player-1] += 1;
        state.combo[player === 1 ? 1 : 0] = 0;
        
        // UI 업데이트
        updateHUD();
        
        if(state.combo[player-1] > 0 && state.combo[player-1] % 3 === 0){
          showFB(`${state.combo[player-1]}연속! 보너스 챌린지!`, true);
          setTimeout(()=>{
            if(state.playing){
              showVennChallenge(player);
            }
          }, 700);
        } else {
          const playerText = state.gameMode === 'practice' ? '플레이어 1' : `플레이어 ${player}`;
          showFB(`${playerText} 정답!`, true);
          setTimeout(()=>{ if(state.playing){ pickNumber(); } }, 650);
        }
      } else {
        // 오답 시 -1점 감점 (최소 0점)
        state.s[player-1] = Math.max(0, state.s[player-1] - 1);
        state.combo[player-1] = 0;
        
        // 0.5초 동안 해당 플레이어 버튼 비활성화
        disablePlayerTemporarily(player, 500);
        
        updateHUD();
        const playerText = state.gameMode === 'practice' ? '플레이어 1' : `플레이어 ${player}`;
        showFB(`${playerText} 오답! -1점`, false);
        setTimeout(()=>{ if(state.playing){ pickNumber(); } }, 650);
      }
    }

    function bindSeg(groupId, onSelect){
      const g = document.getElementById(groupId);
      if(!g) return;
      g.addEventListener('click', (e)=>{
        const btn = e.target.closest('button'); if(!btn) return;
        g.querySelectorAll('button').forEach(x=>x.classList.remove('active'));
        btn.classList.add('active');
        if(typeof onSelect==='function') onSelect(btn.dataset);
      });
    }

    bindSeg('typeA', (d)=>{ state.setA.type = d.type; buildParamOptions('setA'); });
    bindSeg('typeB', (d)=>{ state.setB.type = d.type; buildParamOptions('setB'); });

    if(paramA) paramA.addEventListener('change', ()=>{ state.setA.param = parseInt(paramA.value,10); updateHints(); updateSetDesc(); });
    if(paramB) paramB.addEventListener('change', ()=>{ state.setB.param = parseInt(paramB.value,10); updateHints(); updateSetDesc(); });

    function bindSimpleSeg(id, fn){ bindSeg(id, (d)=> fn(d)); }
    bindSimpleSeg('timeSeg', (d)=>{ state.time = parseInt(d.t,10); state.timeLeft = state.time; updateHUD(); });
    bindSimpleSeg('modeSeg', (d)=>{ 
      state.difficulty = d.m; 
      // 게임 시작 전에도 버튼 레이아웃 업데이트
      updateButtonLayout();
    });

    document.addEventListener('click', (e)=>{
      const b = e.target.closest('button'); if(!b) return;
      if(b.dataset && b.dataset.p){ handleAnswer(parseInt(b.dataset.p,10), b.dataset.a); }
    });

    document.addEventListener('keydown', (e)=>{
      if(!state.playing) return;
      const k = e.key.toLowerCase();
      
      // 연습모드에서는 플레이어 1 키만 작동
      if(state.gameMode === 'practice'){
        if (state.disabledPlayers.includes(1)) return; // 비활성화된 플레이어는 무시
        const p1Answer = getAnswerFromKey(k, 'p1');
        if(p1Answer) return handleAnswer(1, p1Answer);
      } else {
        // PvP모드에서는 모든 키 작동
        const p1Answer = getAnswerFromKey(k, 'p1');
        if(p1Answer && !state.disabledPlayers.includes(1)) {
          return handleAnswer(1, p1Answer);
        }
        
        const p2Answer = getAnswerFromKey(k, 'p2');
        if(p2Answer && !state.disabledPlayers.includes(2)) {
          return handleAnswer(2, p2Answer);
        }
      }
    });
    
    // 키보드 키에 따라 답을 반환하는 함수 (랜덤 순서 고려)
    function getAnswerFromKey(key, player) {
      const p1Keys = ['q', 'w', 'e', 'r'];
      const p2Keys = ['u', 'i', 'o', 'p'];
      
      let keyIndex = -1;
      if(player === 'p1') {
        keyIndex = p1Keys.indexOf(key);
      } else if(player === 'p2') {
        keyIndex = p2Keys.indexOf(key);
      }
      
      if(keyIndex === -1) return null;
      
      // 하드 모드가 아니면 기본 순서 사용
      const isHardMode = player === 'p1' ? state.s[0] >= 10 : state.s[1] >= 10;
      if(!isHardMode) {
        const defaultAnswers = ['A_MINUS_B', 'AB', 'B_MINUS_A', 'NONE'];
        return defaultAnswers[keyIndex];
      }
      
      // 하드 모드면 랜덤 순서 사용
      const playerKey = player === 'p1' ? 'p1' : 'p2';
      return state.buttonOrder[playerKey][keyIndex];
    }

    // Canvas 기반 클릭 이벤트는 위에서 이미 추가됨

    vennCheck.addEventListener('click', checkVennAnswer);
    vennNext.addEventListener('click', closeVennChallenge);

    function randomizeSet(setKey){
      const types = ['mul','div','prime'];
      const type = types[randInt(0, types.length-1)];
      state[setKey].type = type;
      if(type==='mul'){
        const upTo = Math.min(10, state.N);
        state[setKey].param = randInt(2, Math.max(2, upTo));
      } else if(type==='div'){
        let comps = compositeNonSquaresUpTo(state.N);
        if(!comps.length){
          state[setKey].type = 'mul';
          const upTo = Math.min(10, state.N);
          state[setKey].param = Math.min(10, Math.max(2, upTo));
        } else {
          state[setKey].param = comps[randInt(0, comps.length-1)];
        }
      } else {
        state[setKey].param = null;
      }
      
      // 버튼 활성 상태 업데이트
      const typeGroup = setKey === 'setA' ? typeA : typeB;
      typeGroup.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
      const activeBtn = typeGroup.querySelector(`[data-type="${state[setKey].type}"]`);
      if(activeBtn) activeBtn.classList.add('active');
      
      buildParamOptions(setKey);
    }

    const randBtn = document.getElementById('randomize');
    if(randBtn){
      randBtn.addEventListener('click', ()=>{
        randomizeSet('setA');
        let tries=0; 
        do { randomizeSet('setB'); tries++; }
        while(tries<5 && state.setB.type===state.setA.type && state.setB.param===state.setA.param);
      });
    }

    // Mode selection buttons
    const practiceBtn = document.getElementById('practiceMode');
    const pvpBtn = document.getElementById('pvpMode');
    
    if(practiceBtn) {
      practiceBtn.addEventListener('click', ()=>{
        state.gameMode = 'practice';
        startGame();
      });
    }
    
    if(pvpBtn) {
      pvpBtn.addEventListener('click', ()=>{
        state.gameMode = 'pvp';
        startGame();
      });
    }
    
    const againBtn = document.getElementById('again');
    if(againBtn) againBtn.addEventListener('click', ()=>{ endOv.style.display='none'; startGame(); });
    const settingsBtn = document.getElementById('settings');
    if(settingsBtn) settingsBtn.addEventListener('click', ()=>{ endOv.style.display='none'; startOv.style.display='flex'; });
    
    // 메인화면 돌아가기 버튼
    const homeBtn = document.getElementById('homeBtn');
    if(homeBtn) {
      homeBtn.addEventListener('click', () => {
        // 게임 중이면 타이머 정리
        if(state.playing) {
          clearInterval(state.timer);
          state.playing = false;
        }
        
        // 모든 비활성화 타이머 정리
        Object.values(state.disableTimers).forEach(timer => clearTimeout(timer));
        state.disableTimers = {};
        state.disabledPlayers = [];
        
        // 모든 버튼 활성화
        enablePlayerButtons(1);
        enablePlayerButtons(2);
        
        // 모든 오버레이 숨기고 시작 화면 표시
        endOv.style.display = 'none';
        startOv.style.display = 'flex';
      });
    }
    
    // 룰북 버튼 이벤트 리스너
    const rulesBtn = document.getElementById('rulesBtn');
    const rulesModal = document.getElementById('rulesModal');
    const rulesClose = document.getElementById('rulesClose');
    
    if(rulesBtn) {
      rulesBtn.addEventListener('click', () => {
        rulesModal.style.display = 'flex';
        initRulesVenn();
      });
    }
    
    if(rulesClose) {
      rulesClose.addEventListener('click', () => {
        rulesModal.style.display = 'none';
      });
    }
    
    // 룰북 모달 외부 클릭 시 닫기
    if(rulesModal) {
      rulesModal.addEventListener('click', (e) => {
        if(e.target === rulesModal) {
          rulesModal.style.display = 'none';
        }
      });
    }

    if(maxNInput) maxNInput.addEventListener('change', ()=>{ state.N = Math.max(10, Math.min(100, parseInt(maxNInput.value||30,10))); buildParamOptions('setA'); buildParamOptions('setB'); });
    state.N = parseInt(maxNInput.value,10);
    buildParamOptions('setA');
    buildParamOptions('setB');
    updateHints(); 
    updateSetDesc();
    
    // 초기 버튼 레이아웃 설정
    updateButtonLayout();
    
    // 룰북 벤다이어그램 상태
    const rulesVennState = {
      selectedRegions: [],
      canvas: null,
      ctx: null,
      currentProblem: null,
      isAnswered: false
    };
    
    // 벤다이어그램 영역과 집합 연산 매핑
    const regionToSetOperation = {
      'onlyA': 'A-B : A에만 속함',
      'intersection': 'A∩B : A와 B모두에 속함',
      'onlyB': 'B-A : B에만 속함',
      'outside': '(A∪B)ᶜ : A와 B에 모두 속하지 않음'
    };
    
    // 룰북 벤다이어그램 초기화
    function initRulesVenn() {
      rulesVennState.canvas = document.getElementById('rulesVennCanvas');
      rulesVennState.ctx = rulesVennState.canvas.getContext('2d');
      rulesVennState.selectedRegions = [];
      rulesVennState.currentProblem = null;
      rulesVennState.isAnswered = false;
      
      // 통합 시스템에 캔버스 설정
      VennDiagram.rules.canvas = rulesVennState.canvas;
      
      // 캔버스 크기 조정 - 고정 크기로 설정
      const canvas = rulesVennState.canvas;
      const container = canvas.parentElement;
      const containerWidth = container.clientWidth;
      
      // 최대 너비를 컨테이너의 90%로 제한하되, 최소 300px, 최대 500px
      const maxWidth = Math.min(Math.max(containerWidth * 0.9, 300), 500);
      const aspectRatio = 5 / 4; // 500:400 비율
      const newWidth = maxWidth;
      const newHeight = newWidth / aspectRatio;
      
      // 캔버스 크기 설정
      canvas.width = newWidth;
      canvas.height = newHeight;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      
      // 기존 이벤트 리스너 제거 후 새로 추가
      canvas.removeEventListener('click', handleRulesVennClick);
      canvas.addEventListener('click', handleRulesVennClick);
      
      drawRulesVenn();
      updateRegionMeaning();
      updatePracticeResult();
      
      // 버튼 이벤트 리스너 추가
      setupPracticeButtons();
    }
    
    // 연습 버튼 이벤트 리스너 설정
    function setupPracticeButtons() {
      const practiceEasy = document.getElementById('practiceEasy');
      const practiceHard = document.getElementById('practiceHard');
      const practiceNext = document.getElementById('practiceNext');
      
      if(practiceEasy) {
        practiceEasy.addEventListener('click', () => {
          generatePracticeProblem('easy');
          setActiveButton(practiceEasy);
        });
      }
      
      if(practiceHard) {
        practiceHard.addEventListener('click', () => {
          generatePracticeProblem('hard');
          setActiveButton(practiceHard);
        });
      }
      
      if(practiceNext) {
        practiceNext.addEventListener('click', () => {
          if(rulesVennState.currentProblem) {
            generatePracticeProblem(rulesVennState.currentProblem.difficulty);
          }
        });
      }
    }
    
    // 활성 버튼 설정
    function setActiveButton(activeBtn) {
      document.querySelectorAll('.practice-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      activeBtn.classList.add('active');
    }
    
    // 연습 문제 생성
    function generatePracticeProblem(difficulty) {
      const problems = difficulty === 'easy' ? vennProblemsEasy : vennProblemsHard;
      const problem = problems[randInt(0, problems.length - 1)];
      
      rulesVennState.currentProblem = {
        ...problem,
        difficulty: difficulty
      };
      rulesVennState.selectedRegions = [];
      rulesVennState.isAnswered = false;
      
      // 문제 표시
      const questionEl = document.getElementById('practiceQuestion');
      questionEl.textContent = problem.question;
      
      // 벤다이어그램 다시 그리기
      drawRulesVenn();
      updateRegionMeaning();
      updatePracticeResult();
    }
    
    // 룰북 벤다이어그램 함수들을 통합 시스템으로 대체
    function drawRulesVenn() {
      VennDiagram.draw('rules', rulesVennState.selectedRegions, false, []);
    }
    
    function drawRulesVennRegion(region, color, opacity) {
      VennDiagram.drawRegion('rules', region, color, opacity);
    }
    
    // 룰북 벤다이어그램 클릭 처리 (통합 시스템 사용)
    function handleRulesVennClick(e) {
      const canvas = rulesVennState.canvas;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      
      const region = VennDiagram.getRegionAtPoint('rules', x, y);
      if (region) {
        toggleRulesVennRegion(region);
      }
    }
    
    // 룰북 벤다이어그램 영역 토글
    function toggleRulesVennRegion(region) {
      if (rulesVennState.isAnswered) return; // 이미 답을 확인한 경우 무시
      
      if (rulesVennState.selectedRegions.includes(region)) {
        rulesVennState.selectedRegions = rulesVennState.selectedRegions.filter(r => r !== region);
      } else {
        rulesVennState.selectedRegions.push(region);
      }
      
      drawRulesVenn();
      updateRegionMeaning();
      checkPracticeAnswer();
    }
    
    // 연습 문제 정답 확인
    function checkPracticeAnswer() {
      if (!rulesVennState.currentProblem || rulesVennState.isAnswered) return;
      
      const selected = [...rulesVennState.selectedRegions].sort();
      const correct = [...rulesVennState.currentProblem.answer].sort();
      const isCorrect = JSON.stringify(selected) === JSON.stringify(correct);
      
      if (isCorrect) {
        rulesVennState.isAnswered = true;
        updatePracticeResult('correct', '정답입니다! 🎉');
      } else if (rulesVennState.selectedRegions.length > 0) {
        updatePracticeResult('wrong', '다시 시도해보세요!');
      } else {
        updatePracticeResult('empty', '');
      }
    }
    
    // 영역 의미 업데이트
    function updateRegionMeaning() {
      const regionMeaningEl = document.getElementById('regionMeaning');
      if (!regionMeaningEl) return;
      
      if (rulesVennState.selectedRegions.length === 1) {
        const selectedRegion = rulesVennState.selectedRegions[0];
        regionMeaningEl.textContent = regionToSetOperation[selectedRegion] || '';
      } else {
        regionMeaningEl.textContent = '';
      }
    }
    
    // 연습 결과 업데이트
    function updatePracticeResult(type = 'empty', message = '') {
      const resultEl = document.getElementById('practiceResult');
      resultEl.className = `practice-result ${type}`;
      resultEl.textContent = message;
    }
  });
  </script>
</body>
</html>