

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>도미니어링 (Domineering)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .grid-cell {
            transition: all 0.2s ease;
        }
        .grid-cell:hover {
            background-color: #f0f0f0;
        }
        .preview-vertical {
            background-color: rgba(66, 165, 245, 0.4);
        }
        .preview-horizontal {
            background-color: rgba(239, 83, 80, 0.4);
        }
        .tile-vertical {
            background-color: #42A5F5;
        }
        .tile-horizontal {
            background-color: #EF5350;
        }
        .player-active {
            border: 3px solid #FFD700;
            background-color: rgba(255, 215, 0, 0.1);
        }
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.5);
        }
        .cell-selected {
            background-color: #FFD700 !important;
            border: 2px solid #FFA000;
        }
        .cell-valid-pair {
            background-color: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <!-- Header -->
    <div class="text-center py-6">
        <h1 class="text-4xl font-bold text-gray-800 mb-6">도미니어링 (Domineering)</h1>
        
        <!-- Turn Display and New Game Button -->
        <div class="flex items-center justify-center gap-8 mb-6">
            <div id="currentTurnDisplay" class="flex items-center gap-3 bg-white px-6 py-3 rounded-xl shadow-lg">
                <div id="turnIcon" class="flex flex-col gap-1">
                    <div class="w-4 h-8 bg-blue-400 rounded"></div>
                </div>
                <div>
                    <p id="turnText" class="text-xl font-bold text-blue-500">세로 플레이어 턴</p>
                    <p id="turnInstruction" class="text-sm text-gray-600">두 칸을 세로로 선택하세요</p>
                </div>
            </div>
            
            <button id="newGameBtn" class="bg-gray-800 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition-colors font-semibold">
                새 게임
            </button>
        </div>
        
        <!-- Error Modal Popup -->
        <div id="errorModal" class="fixed top-0 left-0 right-0 z-50 hidden">
            <div class="flex justify-center pt-20">
                <div class="bg-white border-2 border-red-400 text-red-700 px-6 py-4 rounded-xl shadow-2xl max-w-md mx-4">
                    <div class="text-center">
                        <div class="text-2xl mb-2">⚠️</div>
                        <p id="errorText" class="font-semibold text-lg"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="flex justify-center px-4">
        <!-- Game Board -->
        <div class="bg-white p-6 rounded-xl shadow-lg">
            <div id="gameBoard" class="grid grid-cols-8 gap-1 bg-gray-300 p-2 rounded-lg">
                <!-- Board cells will be generated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="fixed inset-0 modal-overlay hidden items-center justify-center z-50">
        <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-md mx-4">
            <h2 id="winnerText" class="text-3xl font-bold text-gray-800 mb-4"></h2>
            <p class="text-gray-600 mb-6">축하합니다! 훌륭한 전략이었습니다.</p>
            <button id="playAgainBtn" class="bg-gray-800 text-white px-6 py-3 rounded-lg hover:bg-gray-700 transition-colors font-semibold">
                다시 하기
            </button>
        </div>
    </div>

    <script>
        class DomineeringGame {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(0)); // 0: empty, 1: vertical, 2: horizontal
                this.currentPlayer = 1; // 1: vertical (blue), 2: horizontal (red)
                this.gameOver = false;
                this.previewCells = [];
                this.selectedCells = []; // Track selected cells for two-step placement
                
                this.initializeBoard();
                this.bindEvents();
            }

            initializeBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell w-12 h-12 bg-white border border-gray-400 cursor-pointer rounded';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        cell.addEventListener('mouseenter', () => this.showPreview(row, col));
                        cell.addEventListener('mouseleave', () => this.hidePreview());
                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        
                        boardElement.appendChild(cell);
                    }
                }
            }

            bindEvents() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('playAgainBtn').addEventListener('click', () => this.newGame());
            }

            newGame() {
                this.board = Array(8).fill().map(() => Array(8).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.selectedCells = [];
                this.hideModal();
                this.initializeBoard();
                this.updatePlayerStatus();
                this.updateTurnDisplay();
            }

            handleCellClick(row, col) {
                if (this.gameOver || this.board[row][col] !== 0) return;
                
                const cellKey = `${row}-${col}`;
                const cellIndex = this.selectedCells.findIndex(cell => cell.key === cellKey);
                
                if (cellIndex !== -1) {
                    // Deselect cell
                    this.selectedCells.splice(cellIndex, 1);
                    this.getCell(row, col).classList.remove('cell-selected');
                } else if (this.selectedCells.length < 2) {
                    // Select cell
                    this.selectedCells.push({ row, col, key: cellKey });
                    this.getCell(row, col).classList.add('cell-selected');
                }
                
                this.updateCellHighlights();
                
                // If two cells selected, check if they form a valid tile
                if (this.selectedCells.length === 2) {
                    if (this.isValidTilePlacement()) {
                        this.hideErrorMessage();
                        setTimeout(() => this.placeTileFromSelection(), 300);
                    } else {
                        this.showErrorMessage();
                        this.clearSelection();
                    }
                }
            }

            isValidTilePlacement() {
                if (this.selectedCells.length !== 2) return false;
                
                const [cell1, cell2] = this.selectedCells;
                const rowDiff = Math.abs(cell1.row - cell2.row);
                const colDiff = Math.abs(cell1.col - cell2.col);
                
                if (this.currentPlayer === 1) {
                    // Vertical player: cells must be vertically adjacent
                    return colDiff === 0 && rowDiff === 1;
                } else {
                    // Horizontal player: cells must be horizontally adjacent
                    return rowDiff === 0 && colDiff === 1;
                }
            }

            updateCellHighlights() {
                // Clear all valid pair highlights
                document.querySelectorAll('.cell-valid-pair').forEach(cell => {
                    cell.classList.remove('cell-valid-pair');
                });
                
                if (this.selectedCells.length === 2 && this.isValidTilePlacement()) {
                    this.selectedCells.forEach(cell => {
                        this.getCell(cell.row, cell.col).classList.add('cell-valid-pair');
                    });
                }
            }

            placeTileFromSelection() {
                if (!this.isValidTilePlacement()) return;
                
                this.selectedCells.forEach(cell => {
                    this.board[cell.row][cell.col] = this.currentPlayer;
                    const cellElement = this.getCell(cell.row, cell.col);
                    cellElement.classList.remove('cell-selected', 'cell-valid-pair', 'grid-cell');
                    
                    if (this.currentPlayer === 1) {
                        cellElement.className = 'w-12 h-12 border border-gray-400 rounded tile-vertical';
                    } else {
                        cellElement.className = 'w-12 h-12 border border-gray-400 rounded tile-horizontal';
                    }
                    cellElement.style.cursor = 'default';
                });
                
                this.selectedCells = [];
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                this.updatePlayerStatus();
                this.updateTurnDisplay();
                
                if (!this.hasValidMoves()) {
                    this.endGame();
                }
            }

            showPreview(row, col) {
                if (this.gameOver) return;
                
                this.hidePreview();
                
                if (this.canPlaceTile(row, col)) {
                    this.previewCells = this.getTileCells(row, col);
                    this.previewCells.forEach(([r, c]) => {
                        const cell = this.getCell(r, c);
                        if (this.currentPlayer === 1) {
                            cell.classList.add('preview-vertical');
                        } else {
                            cell.classList.add('preview-horizontal');
                        }
                    });
                }
            }

            hidePreview() {
                this.previewCells.forEach(([r, c]) => {
                    const cell = this.getCell(r, c);
                    cell.classList.remove('preview-vertical', 'preview-horizontal');
                });
                this.previewCells = [];
            }



            canPlaceTile(row, col) {
                const cells = this.getTileCells(row, col);
                return cells.length === 2 && cells.every(([r, c]) => 
                    r >= 0 && r < 8 && c >= 0 && c < 8 && this.board[r][c] === 0
                );
            }

            getTileCells(row, col) {
                if (this.currentPlayer === 1) { // Vertical
                    return [[row, col], [row + 1, col]];
                } else { // Horizontal
                    return [[row, col], [row, col + 1]];
                }
            }

            hasValidMoves() {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.canPlaceTile(row, col)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            getCell(row, col) {
                return document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            }

            updatePlayerStatus() {
                // This method is now simplified since we removed the side UI
            }

            updateTurnDisplay() {
                const turnText = document.getElementById('turnText');
                const turnInstruction = document.getElementById('turnInstruction');
                const turnIcon = document.getElementById('turnIcon');
                
                if (this.currentPlayer === 1) {
                    turnText.textContent = '세로 플레이어 턴';
                    turnText.className = 'text-xl font-bold text-blue-500';
                    turnInstruction.textContent = '두 칸을 세로로 선택하세요';
                    turnIcon.innerHTML = '<div class="w-4 h-8 bg-blue-400 rounded"></div>';
                } else {
                    turnText.textContent = '가로 플레이어 턴';
                    turnText.className = 'text-xl font-bold text-red-500';
                    turnInstruction.textContent = '두 칸을 가로로 선택하세요';
                    turnIcon.innerHTML = '<div class="w-8 h-4 bg-red-400 rounded"></div>';
                }
            }

            endGame() {
                this.gameOver = true;
                const winner = this.currentPlayer === 1 ? 2 : 1; // Previous player wins
                const winnerText = winner === 1 ? '세로 플레이어 승리!' : '가로 플레이어 승리!';
                
                document.getElementById('winnerText').textContent = winnerText;
                document.getElementById('winnerText').className = winner === 1 ? 
                    'text-3xl font-bold text-blue-500 mb-4' : 
                    'text-3xl font-bold text-red-500 mb-4';
                
                this.showModal();
            }

            showModal() {
                const modal = document.getElementById('gameOverModal');
                modal.classList.remove('hidden');
                modal.classList.add('flex');
            }

            hideModal() {
                const modal = document.getElementById('gameOverModal');
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            }

            showErrorMessage() {
                const errorModal = document.getElementById('errorModal');
                const errorText = document.getElementById('errorText');
                
                if (this.currentPlayer === 1) {
                    errorText.textContent = '세로로 2개의 블럭을 클릭하세요.';
                } else {
                    errorText.textContent = '가로로 2개의 블럭을 클릭하세요.';
                }
                
                errorModal.classList.remove('hidden');
                
                // Auto hide after 2.5 seconds
                setTimeout(() => {
                    this.hideErrorMessage();
                }, 2500);
            }

            hideErrorMessage() {
                const errorModal = document.getElementById('errorModal');
                errorModal.classList.add('hidden');
            }

            clearSelection() {
                this.selectedCells.forEach(cell => {
                    this.getCell(cell.row, cell.col).classList.remove('cell-selected', 'cell-valid-pair');
                });
                this.selectedCells = [];
            }
        }

        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const game = new DomineeringGame();
            game.updateTurnDisplay();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'961b408a60a9d1d6',t:'MTc1MjkzODk0My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
