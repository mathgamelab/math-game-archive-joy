<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¢Œí‘œí‰ë©´ ì²´ìŠ¤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;600;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; overscroll-behavior: none; }
        .grid-dot { width: 5px; height: 5px; background: #a0aec0; border-radius: 50%; }
        .card-container { -ms-overflow-style: none; scrollbar-width: none; scroll-behavior: smooth; }
        .card-container::-webkit-scrollbar { display: none; }
        .card-hover { transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .card-hover:hover:not(.card-selected) { transform: translateY(-8px); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        .card-selected { transform: translateY(-20px) scale(1.03); box-shadow: 0 25px 50px -12px rgba(59, 130, 246, 0.25); border: 2px solid #3b82f6; }
        .player-piece { 
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55); 
            transform-origin: center;
        }
        .quiz-overlay, .debug-overlay, .rulebook-overlay { backdrop-filter: blur(8px); background: rgba(17, 24, 39, 0.6); }
        .axis-line { background: #9ca3af; }
        @keyframes cardUse { 0% { transform: translateY(0) scale(1); opacity: 1; } 50% { transform: translateY(-40px) scale(1.1); opacity: 1; } 100% { transform: translateY(-80px) scale(0.5) rotate(15deg); opacity: 0; } }
        .card-use-animation { animation: cardUse 0.7s ease-out forwards; }
        .toast-notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 9999px; color: white; font-weight: 600; z-index: 1000; opacity: 0; transition: opacity 0.5s, top 0.5s; }
        .mode-select-button { transition: all 0.2s ease-in-out; }
        .mode-select-button:hover { transform: scale(1.05); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        #turnTimerBar { transition: width 1s linear; }
        .gigantified-effect {
            position: absolute;
            background-color: rgba(255, 235, 59, 0.3);
            border: 2px dashed #FBBF24;
            border-radius: 10px;
            z-index: 29;
            pointer-events: none;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">

    <div id="modeSelectionScreen" class="w-full max-w-md p-8 bg-white rounded-2xl shadow-2xl text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">ì¢Œí‘œí‰ë©´ ì²´ìŠ¤â™</h1>
        <p class="text-gray-500 mb-8">í”Œë ˆì´í•  ëª¨ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
        <div class="space-y-4">
            <button onclick="startGame('practice')" class="mode-select-button w-full bg-cyan-500 hover:bg-cyan-600 text-white py-4 rounded-lg font-semibold text-lg">ğŸš€ ì—°ìŠµ ëª¨ë“œ (í˜¼ìí•˜ê¸°)</button>
            <button onclick="startGame('pvp')" class="mode-select-button w-full bg-purple-500 hover:bg-purple-600 text-white py-4 rounded-lg font-semibold text-lg">ğŸ›¸ PvP ëª¨ë“œ (ë‘˜ì´í•˜ê¸°)</button>
        </div>
        <div class="mt-10 text-center text-sm text-gray-400">
            <p>í–‰ë³µí•œ ìˆ˜í•™, í•¨ê»˜ ë§Œë“¤ì–´ìš”! ğŸ˜Š</p>
            <p>Â© í–‰ë³µí•œìœ¤ìŒ¤ | <a href="https://blog.naver.com/happy_yoonssam" target="_blank" class="hover:underline text-gray-500">https://blog.naver.com/happy_yoonssam</a></p>
        </div>
    </div>

    <div id="gameContainer" class="hidden w-full h-screen flex-col sm:flex-row relative">
        <div class="absolute top-4 right-4 flex gap-2 z-20">
             <button id="rulebookBtn" title="ë£°ë¶ ë³´ê¸°" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-200 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
             </button>
             <button onclick="exitToMenu()" title="ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-200 transition"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></button>
        </div>
        
        <div id="opponentHandContainer" class="absolute top-2 left-4 flex items-center gap-2 z-10"></div>

        <div id="mainContentArea" class="flex flex-1 w-full max-w-screen-2xl mx-auto overflow-hidden">
            <div class="flex-1 p-4 sm:p-6 flex justify-center pt-16">
                <div class="relative w-full h-full max-w-[440px] max-h-[440px] sm:max-w-[520px] sm:max-h-[520px] aspect-square">
                    <div id="gameBoard" class="bg-white border-2 border-gray-200 rounded-lg shadow-lg w-full h-full relative">
                        <div class="axis-line absolute w-full h-0.5" style="top: 50%; left: 0;"></div>
                        <div id="xAxisLabel" class="absolute cursor-pointer" style="right: -18px; top: 50%; transform: translateY(-50%);"><div class="flex items-center"><div style="width: 0; height: 0; border-left: 8px solid #4b5563; border-top: 5px solid transparent; border-bottom: 5px solid transparent;"></div><span class="ml-1 text-base font-bold text-gray-700">X</span></div></div>
                        <div class="axis-line absolute h-full w-0.5" style="left: 50%; top: 0;"></div>
                        <div id="yAxisLabel" class="absolute cursor-pointer" style="left: 50%; top: -24px; transform: translateX(-50%);"><div class="flex flex-col items-center"><div style="width: 0; height: 0; border-bottom: 8px solid #4b5563; border-left: 5px solid transparent; border-right: 5px solid transparent;"></div><span class="mt-1 text-base font-bold text-gray-700">Y</span></div></div>
                        <div id="gridDots" class="absolute inset-0"></div>
                        <div id="axisLabels" class="absolute inset-0"></div>
                        <div id="player1Gigantified" class="gigantified-effect hidden"></div>
                        <div id="player2Gigantified" class="gigantified-effect hidden"></div>
                        <div id="player1Piece" class="player-piece absolute flex items-center justify-center" style="width: 36px; height: 36px; z-index: 30; font-size: 28px;">ğŸš€</div>
                        <div id="player2Piece" class="player-piece absolute hidden items-center justify-center" style="width: 36px; height: 36px; z-index: 30; font-size: 28px;">ğŸ›¸</div>
                        <div id="targetGoal" class="absolute bg-green-400 rounded-full shadow-lg flex items-center justify-center text-white font-bold" style="width: 28px; height: 28px; z-index: 5;">ğŸ¯</div>
                    </div>
                </div>
            </div>
            <div id="rightPanel" class="w-full sm:w-80 bg-gray-50 p-4 sm:p-6 flex flex-col border-l border-gray-200">
                <div id="infoPanel" class="bg-white rounded-xl shadow p-5 mb-6"><h2 id="infoPanelTitle" class="text-xl font-bold text-gray-800 mb-4">ê²Œì„ ì •ë³´</h2><div id="infoPanelContent" class="space-y-3"></div></div>
                <div id="scoreboard" class="hidden bg-white rounded-xl shadow p-5 mb-6"><h2 class="text-xl font-bold text-gray-800 mb-4">ìŠ¤ì½”ì–´</h2><div class="space-y-3"><div class="flex justify-between items-center text-lg"><span class="font-semibold text-cyan-600">ğŸš€ Player 1</span><span id="p1Score" class="font-bold text-gray-800">0</span></div><div class="flex justify-between items-center text-lg"><span class="font-semibold text-purple-600">ğŸ›¸ Player 2</span><span id="p2Score" class="font-bold text-gray-800">0</span></div></div></div>
                <div id="debugPanel" class="hidden bg-red-100 border border-red-300 rounded-xl p-5 mb-6"><h2 class="text-xl font-bold text-red-700 mb-4">ë””ë²„ê·¸ ë©”ë‰´</h2><div class="grid grid-cols-1 gap-3"><button id="summonCardBtn" class="w-full bg-red-500 hover:bg-red-600 text-white py-2 rounded-lg font-semibold">ì¹´ë“œ ì†Œí™˜</button></div></div>
                <div class="bg-white rounded-xl shadow p-5"><div class="flex justify-between items-center mb-4"><span id="turnIndicator" class="text-gray-600"></span><span class="text-2xl font-bold text-indigo-600" id="turnDisplay">í„´ 1</span></div><div class="grid grid-cols-1 gap-3"><button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-3 rounded-lg font-semibold shadow-md transition-all" onclick="endTurn()">í„´ ì¢…ë£Œ</button></div><div id="turnTimerContainer" class="w-full bg-gray-200 rounded-full h-2.5 mt-4"><div id="turnTimerBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 100%"></div></div></div>
            </div>
        </div>
        <div id="bottomPanel" class="fixed bottom-0 left-0 right-0 bg-white/80 backdrop-blur-sm border-t-2 border-gray-200 p-4 sm:p-6 z-10">
            <div class="max-w-7xl mx-auto flex items-center gap-x-4 sm:gap-x-6">
                <div id="cardContainer" class="card-container flex-1 flex space-x-4 overflow-x-auto py-2"></div>
                <div class="flex items-center space-x-3 flex-shrink-0">
                    <button id="useCardBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all disabled:opacity-50 disabled:cursor-not-allowed" onclick="useSelectedCard()" disabled>ì¹´ë“œ<br>ì‚¬ìš©</button>
                    <button id="discardCardBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all disabled:opacity-50 disabled:cursor-not-allowed" onclick="discardCard()">ì¹´ë“œ<br>ë²„ë¦¬ê¸°</button>
                    <button id="quizBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all" onclick="showQuiz()">í€´ì¦ˆ<br>ë„ì „</button>
                </div>
            </div>
        </div>
    </div>
    <div id="quizModal" class="fixed inset-0 quiz-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full mx-auto"><div class="flex justify-between items-center mb-4"><h3 id="quizTitle" class="text-xl font-bold text-gray-800">ë„í˜•ì˜ ì´ë™ í€´ì¦ˆ</h3><div id="quizTimer" class="text-2xl font-bold text-red-500"></div></div><div id="quizQuestion" class="text-gray-700 mb-4 text-center bg-gray-100 p-4 rounded-lg"></div><div id="quizOptions" class="space-y-3"></div><div class="flex space-x-3 mt-6"><button class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition-all" onclick="submitQuiz()">ì œì¶œ</button></div></div></div>
    <div id="summonListModal" class="fixed inset-0 debug-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-2xl w-full mx-auto"><div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold text-gray-800">ì¹´ë“œ ì†Œí™˜</h3><button id="closeSummonListBtn" class="text-gray-500 hover:text-gray-800">âœ–</button></div><div id="summonListContainer" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 max-h-96 overflow-y-auto"></div></div></div>
    <div id="rulebookModal" class="fixed inset-0 rulebook-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-3xl w-full mx-auto h-5/6 flex flex-col"><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold text-gray-800">ê²Œì„ ë£°ë¶</h2><button id="closeRulebookBtn" class="text-gray-500 hover:text-gray-800 text-2xl">âœ–</button></div><div id="rulebookContent" class="prose max-w-none overflow-y-auto"></div></div></div>
    <div id="toastContainer"></div>

    <script>
        // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
        let gameMode = ''; 
        let players = { 
            p1: { pos: {x: 0, y: 0}, previousPos: null, cards: [], pieceEl: null, gigantifiedEl: null, character: 'ğŸš€', name: 'Player 1', isGigantified: false }, 
            p2: { pos: {x: 0, y: 0}, previousPos: null, cards: [], pieceEl: null, gigantifiedEl: null, character: 'ğŸ›¸', name: 'Player 2', isGigantified: false } 
        };
        let practicePlayer = { pos: {x: 0, y: 0}, targetPos: {x: 0, y: 0}, cards: [], previousPos: null }; 
        let pvpScores = { p1: 0, p2: 0 }; 
        let currentPlayerId = 'p1';
        let nextRoundStarterId = null;
        let selectedCard = null, selectedCardElement = null; 
        let cardsUsedThisTurn = 0, currentTurn = 1, quizSolvedThisTurn = false; 
        let isDebugMode = false; let isEncoreActive = false; let isKnightMoveActive = false;
        const MAX_CARDS_PER_TURN = 2; const MAX_HAND_SIZE = 6; const TURN_TIME_LIMIT = 120;
        
        // --- ê²Œì„ ì„¤ì • ë³€ìˆ˜ ---
        const GRID_MIN = -5, GRID_MAX = 5, GRID_SIZE = GRID_MAX - GRID_MIN;

        // --- DOM ìš”ì†Œ ìºì‹± ---
        const gameContainer = document.getElementById('gameContainer'), modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const player1Piece = document.getElementById('player1Piece'), player2Piece = document.getElementById('player2Piece');
        const targetGoal = document.getElementById('targetGoal'); const infoPanelTitle = document.getElementById('infoPanelTitle'), infoPanelContent = document.getElementById('infoPanelContent');
        const scoreboard = document.getElementById('scoreboard'), p1ScoreEl = document.getElementById('p1Score'), p2ScoreEl = document.getElementById('p2Score');
        const turnIndicator = document.getElementById('turnIndicator'), turnDisplayEl = document.getElementById('turnDisplay');
        const useCardBtn = document.getElementById('useCardBtn'), discardCardBtn = document.getElementById('discardCardBtn');
        const cardContainer = document.getElementById('cardContainer'), quizModal = document.getElementById('quizModal');
        const gameBoard = document.getElementById('gameBoard'), quizBtn = document.getElementById('quizBtn');
        const mainContentArea = document.querySelector('#gameContainer > .flex');
        const bottomPanel = document.getElementById('bottomPanel');
        const opponentHandContainer = document.getElementById('opponentHandContainer');
        const xAxisLabel = document.getElementById('xAxisLabel'), yAxisLabel = document.getElementById('yAxisLabel');
        const debugPanel = document.getElementById('debugPanel'); const summonListModal = document.getElementById('summonListModal'); const summonListContainer = document.getElementById('summonListContainer');
        const turnTimerContainer = document.getElementById('turnTimerContainer'), turnTimerBar = document.getElementById('turnTimerBar');
        const rulebookModal = document.getElementById('rulebookModal'); const rulebookContent = document.getElementById('rulebookContent');
        
        // --- ì¹´ë“œ ë± ì •ì˜ (ë ˆì–´ ì¹´ë“œ ì¶”ê°€) ---
        const cardDeck = [ { type: 'move', value: { x: 1 }, text: 'X : +1', educationalDesc: 'xì¶• ë°©í–¥ìœ¼ë¡œ<br>1ë§Œí¼ í‰í–‰ì´ë™', color: 'blue' }, { type: 'move', value: { x: 2 }, text: 'X : +2', educationalDesc: 'xì¶• ë°©í–¥ìœ¼ë¡œ<br>2ë§Œí¼ í‰í–‰ì´ë™', color: 'blue' }, { type: 'move', value: { x: 3 }, text: 'X : +3', educationalDesc: 'xì¶• ë°©í–¥ìœ¼ë¡œ<br>3ë§Œí¼ í‰í–‰ì´ë™', color: 'blue' }, { type: 'move', value: { x: -1 }, text: 'X : -1', educationalDesc: 'xì¶• ë°©í–¥ìœ¼ë¡œ<br>-1ë§Œí¼ í‰í–‰ì´ë™', color: 'orange' }, { type: 'move', value: { x: -2 }, text: 'X : -2', educationalDesc: 'xì¶• ë°©í–¥ìœ¼ë¡œ<br>-2ë§Œí¼ í‰í–‰ì´ë™', color: 'orange' }, { type: 'move', value: { y: 1 }, text: 'Y : +1', educationalDesc: 'yì¶• ë°©í–¥ìœ¼ë¡œ<br>1ë§Œí¼ í‰í–‰ì´ë™', color: 'green' }, { type: 'move', value: { y: 2 }, text: 'Y : +2', educationalDesc: 'yì¶• ë°©í–¥ìœ¼ë¡œ<br>2ë§Œí¼ í‰í–‰ì´ë™', color: 'green' }, { type: 'move', value: { y: 3 }, text: 'Y : +3', educationalDesc: 'yì¶• ë°©í–¥ìœ¼ë¡œ<br>3ë§Œí¼ í‰í–‰ì´ë™', color: 'green' }, { type: 'move', value: { y: -1 }, text: 'Y : -1', educationalDesc: 'yì¶• ë°©í–¥ìœ¼ë¡œ<br>-1ë§Œí¼ í‰í–‰ì´ë™', color: 'teal' }, { type: 'move', value: { y: -2 }, text: 'Y : -2', educationalDesc: 'yì¶• ë°©í–¥ìœ¼ë¡œ<br>-2ë§Œí¼ í‰í–‰ì´ë™', color: 'teal' }, ];
        const specialCardDeck = [ { type: 'special', value: 'origin', text: 'ì›ì  ëŒ€ì¹­', educationalDesc: 'ì›ì ì— ëŒ€í•˜ì—¬<br>ëŒ€ì¹­ì´ë™', color: 'purple' }, { type: 'special', value: 'x-axis', text: 'Xì¶• ëŒ€ì¹­', educationalDesc: 'xì¶•ì— ëŒ€í•˜ì—¬<br>ëŒ€ì¹­ì´ë™', color: 'red' }, { type: 'special', value: 'y-axis', text: 'Yì¶• ëŒ€ì¹­', educationalDesc: 'yì¶•ì— ëŒ€í•˜ì—¬<br>ëŒ€ì¹­ì´ë™', color: 'indigo' }, ];
        const rareCardDeck = [ { type: 'rare', value: 'sniper', text: 'ì €ê²©ì´', educationalDesc: 'ìƒëŒ€ë°©ê³¼ ê°™ì€ ì§ì„ ì—<br>ìˆë‹¤ë©´ ì¦‰ì‹œ ì¶”ê²©', color: 'slate' }, { type: 'rare', value: 'emergency_escape', text: 'ë¹„ìƒíƒˆì¶œ', educationalDesc: 'ëª¨ë“  í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼<br>ë¬´ì‘ìœ„ë¡œ ì¬ì„¤ì •', color: 'slate' }, { type: 'rare', value: 'magnet', text: 'ìì„', educationalDesc: 'ìƒëŒ€ë°©ì„ 4ì¹¸<br>ê±°ë¦¬ê¹Œì§€ ëŒì–´ì˜¤ê¸°', color: 'slate' }, { type: 'rare', value: 'encore', text: 'ì•µì½œ', educationalDesc: 'ìì‹ ì˜ í„´ì„<br>í•œ ë²ˆ ë” ì§„í–‰', color: 'slate' }, { type: 'rare', value: 'knight', text: 'ë‚˜ì´íŠ¸', educationalDesc: 'ì²´ìŠ¤ ë‚˜ì´íŠ¸ì²˜ëŸ¼<br>í•œ ì¹¸ ì´ë™', color: 'slate' }, { type: 'rare', value: 'gigantify', text: 'ê±°ëŒ€í™”', educationalDesc: '1í„´ê°„ 2x2 í¬ê¸°ë¡œ<br>ì˜ì—­ì„ í™•ì¥', color: 'slate' }, { type: 'rare', value: 'rewind', text: 'ë„ë¥´ë§ˆë¬´', educationalDesc: 'ì´ì „ ìœ„ì¹˜ë¡œ<br>ë˜ëŒì•„ê°‘ë‹ˆë‹¤', color: 'slate' }, ];

        let currentQuiz = null, quizTimerInterval = null; let debugClickSequence = []; let turnTimerInterval = null;

        window.onload = () => { 
            players.p1.pieceEl = player1Piece; 
            players.p2.pieceEl = player2Piece;
            players.p1.gigantifiedEl = document.getElementById('player1Gigantified');
            players.p2.gigantifiedEl = document.getElementById('player2Gigantified');
            window.addEventListener('resize', adjustLayout); 
            xAxisLabel.addEventListener('click', (e) => handleDebugClick(e, 'X')); 
            yAxisLabel.addEventListener('click', (e) => handleDebugClick(e, 'Y')); 
            gameBoard.addEventListener('click', handleBoardClick); 
            document.getElementById('summonCardBtn').addEventListener('click', toggleSummonList);
            document.getElementById('closeSummonListBtn').addEventListener('click', toggleSummonList);
            document.getElementById('rulebookBtn').addEventListener('click', showRulebook);
            document.getElementById('closeRulebookBtn').addEventListener('click', hideRulebook);
        };
        
        function handleDebugClick(e, axis) { e.stopPropagation(); debugClickSequence.push(axis); if (debugClickSequence.length > 2) debugClickSequence.shift(); if (debugClickSequence.join('') === 'XY') { isDebugMode = !isDebugMode; showToast(`ë””ë²„ê·¸ ëª¨ë“œ ${isDebugMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`, isDebugMode ? 'bg-red-500' : 'bg-green-500'); debugClickSequence = []; debugPanel.classList.toggle('hidden'); updateButtons(); if (isDebugMode) { stopTurnTimer(); } else { startTurnTimer(); } } }
        function adjustLayout() { if (gameMode !== '') { mainContentArea.style.paddingBottom = `${bottomPanel.offsetHeight}px`; setupGameBoard(); } }
        function startGame(mode) { gameMode = mode; modeSelectionScreen.classList.add('hidden'); gameContainer.classList.remove('hidden'); gameContainer.classList.add('flex'); if (gameMode === 'pvp') { scoreboard.classList.remove('hidden'); opponentHandContainer.classList.remove('hidden'); turnTimerContainer.classList.remove('hidden'); } else { scoreboard.classList.add('hidden'); opponentHandContainer.classList.add('hidden'); turnTimerContainer.classList.add('hidden'); } adjustLayout(); newGame(); }
        function exitToMenu() { gameContainer.classList.add('hidden'); gameContainer.classList.remove('flex'); modeSelectionScreen.classList.remove('hidden'); pvpScores = { p1: 0, p2: 0 }; isDebugMode = false; debugPanel.classList.add('hidden'); stopTurnTimer(); }

        function setupGameBoard() {
            if (gameMode === '') return;
            const boardSize = gameBoard.clientWidth, unit = boardSize / (GRID_SIZE + 1);
            const gridDotsContainer = document.getElementById('gridDots'), axisLabelsContainer = document.getElementById('axisLabels');
            gridDotsContainer.innerHTML = ''; axisLabelsContainer.innerHTML = '';
            for (let i = 0; i <= GRID_SIZE; i++) for (let j = 0; j <= GRID_SIZE; j++) { const dot = document.createElement('div'); dot.className = 'grid-dot absolute'; dot.style.left = `${i * unit + unit/2 - 2.5}px`; dot.style.top = `${j * unit + unit/2 - 2.5}px`; gridDotsContainer.appendChild(dot); }
            for (let i = GRID_MIN; i <= GRID_MAX; i++) { 
                if (i === 0) continue; 
                const xLabel = document.createElement('span'); 
                xLabel.className = 'absolute text-xs font-medium text-gray-500'; 
                xLabel.textContent = i; 
                xLabel.style.top = '50%'; 
                xLabel.style.left = `${(i - GRID_MIN) * unit + unit/2}px`; 
                xLabel.style.transform = `translate(${i > 0 ? '-20%' : '-80%'}, 8px)`; 
                axisLabelsContainer.appendChild(xLabel); 
                
                const yLabel = document.createElement('span'); 
                yLabel.className = 'absolute text-xs font-medium text-gray-500'; 
                yLabel.textContent = i; 
                yLabel.style.left = '50%'; 
                yLabel.style.top = `${(GRID_MAX - i) * unit + unit/2}px`; 
                yLabel.style.transform = `translate(8px, ${i > 0 ? '-70%' : '-45%'})`; 
                axisLabelsContainer.appendChild(yLabel); 
            }
            updateAllPiecePositions();
        }

        function newGame() {
            currentTurn = 1; cardsUsedThisTurn = 0; selectedCard = null; selectedCardElement = null; quizSolvedThisTurn = false; quizBtn.disabled = false; isEncoreActive = false;
            if (gameMode === 'practice') {
                player1Piece.innerHTML = 'ğŸš€'; player2Piece.classList.add('hidden'); targetGoal.classList.remove('hidden');
                do { practicePlayer.pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; practicePlayer.targetPos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while (Math.abs(practicePlayer.pos.x - practicePlayer.targetPos.x) + Math.abs(practicePlayer.pos.y - practicePlayer.targetPos.y) < 6);
                practicePlayer.cards = []; practicePlayer.previousPos = null; drawInitialCards();
            } else {
                currentPlayerId = nextRoundStarterId || 'p1';
                nextRoundStarterId = null;
                player1Piece.innerHTML = players.p1.character; player2Piece.innerHTML = players.p2.character;
                player2Piece.classList.remove('hidden'); targetGoal.classList.add('hidden');
                let p1Pos, p2Pos;
                do { p1Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; p2Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while ((p1Pos.x === p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === p2Pos.x && p1Pos.y === -p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === -p2Pos.y) || (Math.abs(p1Pos.x - p2Pos.x) + Math.abs(p1Pos.y - p2Pos.y) < 4));
                players.p1.pos = p1Pos; players.p2.pos = p2Pos;
                players.p1.cards = []; players.p2.cards = [];
                players.p1.previousPos = null; players.p2.previousPos = null;
                players.p1.isGigantified = false; players.p2.isGigantified = false;
                drawInitialCards('p1'); drawInitialCards('p2');
            }
            updateUI();
            startTurnTimer();
            if (currentTurn === 1 && pvpScores.p1 === 0 && pvpScores.p2 === 0) { showToast(`${gameMode === 'practice' ? 'ì—°ìŠµ' : 'PvP'} ëª¨ë“œ ì‹œì‘!`, 'bg-blue-500'); }
        }

        function createCardElement(cardData, isMini = false) { const cardElement = document.createElement('div'); const colorMap = { blue: 'text-blue-600', orange: 'text-orange-600', green: 'text-green-600', teal: 'text-teal-600', purple: 'text-purple-600', red: 'text-red-600', indigo: 'text-indigo-600', slate: 'text-slate-600' }; let bgClass = 'bg-white'; let borderClass = 'border-gray-200'; if (cardData.type === 'special') { bgClass = 'bg-sky-50'; borderClass = 'border-sky-200'; } else if (cardData.type === 'rare') { bgClass = 'bg-yellow-50'; borderClass = 'border-yellow-200'; } if (isMini) { cardElement.className = `${bgClass} border ${borderClass} rounded-md p-2 shadow-sm flex-shrink-0`; cardElement.innerHTML = `<div class="text-center"><div class="text-xs font-bold ${colorMap[cardData.color] || 'text-gray-800'}">${cardData.text}</div></div>`; } else { cardElement.className = `card-hover ${bgClass} border-2 ${borderClass} rounded-xl p-4 cursor-pointer shadow-md flex-shrink-0`; cardElement.onclick = () => selectCard(cardElement, cardData); cardElement.innerHTML = `<div class="text-center"><div class="text-lg font-bold ${colorMap[cardData.color] || 'text-gray-800'} mb-2">${cardData.text}</div><div class="text-xs text-gray-500 h-8 flex items-center justify-center">${cardData.educationalDesc}</div></div>`; } return cardElement; }
        function renderPlayerCards() { cardContainer.innerHTML = ''; const currentCards = (gameMode === 'practice') ? practicePlayer.cards : players[currentPlayerId].cards; currentCards.forEach(cardData => { const cardElement = createCardElement(cardData, false); cardContainer.appendChild(cardElement); }); }
        function renderOpponentCards() { opponentHandContainer.innerHTML = ''; if (gameMode !== 'pvp') return; const opponentId = currentPlayerId === 'p1' ? 'p2' : 'p1'; const opponent = players[opponentId]; opponentHandContainer.innerHTML = `<div class="flex items-center gap-2 bg-gray-900/10 backdrop-blur-sm p-2 rounded-lg"><span class="font-bold text-sm mr-2 text-white">${opponent.character} ìƒëŒ€ë°© ì¹´ë“œ:</span></div>`; const cardWrapper = opponentHandContainer.querySelector('div'); opponent.cards.forEach(cardData => { const cardElement = createCardElement(cardData, true); cardWrapper.appendChild(cardElement); }); }
        function drawInitialCards(playerId) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[playerId]; for (let i = 0; i < 4; i++) { targetPlayer.cards.push(cardDeck[Math.floor(Math.random() * cardDeck.length)]); } targetPlayer.cards.push(specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]); }
        function drawNewCards(count, playerId) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[playerId]; for (let i = 0; i < count; i++) { const rand = Math.random(); let drawnCard; if (gameMode === 'pvp' && rand < 0.1) { drawnCard = rareCardDeck[Math.floor(Math.random() * rareCardDeck.length)]; } else if (rand < 0.3) { drawnCard = specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]; } else { drawnCard = cardDeck[Math.floor(Math.random() * cardDeck.length)]; } targetPlayer.cards.push(drawnCard); } }
        function addCardToHand(cardData) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId]; targetPlayer.cards.push(cardData); renderPlayerCards(); }
        function selectCard(element, data) { if (selectedCardElement && selectedCardElement !== element) selectedCardElement.classList.remove('card-selected'); element.classList.toggle('card-selected'); if (element.classList.contains('card-selected')) { selectedCard = data; selectedCardElement = element; } else { selectedCard = null; selectedCardElement = null; } updateButtons(); }
        
        function useSelectedCard() {
            const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
            if (!selectedCard || (!isDebugMode && cardsUsedThisTurn >= MAX_CARDS_PER_TURN)) return;
            
            if (selectedCard.type === 'move' || selectedCard.type === 'special' || (selectedCard.type === 'rare' && ['sniper', 'magnet', 'rewind'].includes(selectedCard.value))) {
                targetPlayer.previousPos = { ...targetPlayer.pos }; 
            }

            const elementToRemove = selectedCardElement; 
            let newPos = { ...targetPlayer.pos }; let success = true;

            if (selectedCard.type === 'move' || selectedCard.type === 'special') {
                if (selectedCard.type === 'move') { newPos.x += selectedCard.value.x || 0; newPos.y += selectedCard.value.y || 0; } 
                else { if (selectedCard.value === 'origin') newPos = { x: -targetPlayer.pos.x, y: -targetPlayer.pos.y }; else if (selectedCard.value === 'x-axis') newPos = { x: targetPlayer.pos.x, y: -targetPlayer.pos.y }; else if (selectedCard.value === 'y-axis') newPos = { x: -targetPlayer.pos.x, y: targetPlayer.pos.y }; }
            } else if (selectedCard.type === 'rare') {
                const me = targetPlayer; const opponent = players[currentPlayerId === 'p1' ? 'p2' : 'p1'];
                switch(selectedCard.value) {
                    case 'sniper': if (me.pos.x === opponent.pos.x || me.pos.y === opponent.pos.y) { showToast('ì‚¬ì •ê±°ë¦¬ í¬ì°©! ìƒëŒ€ë°©ì„ ì¶”ê²©í•©ë‹ˆë‹¤!', 'bg-red-700'); newPos = { ...opponent.pos }; } else { showToast('ìƒëŒ€ë°©ì´ ì‚¬ì •ê±°ë¦¬ì— ì—†ìŠµë‹ˆë‹¤.', 'bg-gray-500'); success = false; } break;
                    case 'emergency_escape': showToast('ë¹„ìƒíƒˆì¶œ! ìœ„ì¹˜ë¥¼ ì¬ì„¤ì •í•©ë‹ˆë‹¤!', 'bg-yellow-500'); let p1Pos, p2Pos; do { p1Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; p2Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while ((p1Pos.x === p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === p2Pos.x && p1Pos.y === -p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === -p2Pos.y) || (Math.abs(p1Pos.x - p2Pos.x) + Math.abs(p1Pos.y - p2Pos.y) < 4)); players.p1.pos = p1Pos; players.p2.pos = p2Pos; newPos = players[currentPlayerId].pos; break;
                    case 'magnet': const dist = Math.abs(me.pos.x - opponent.pos.x) + Math.abs(me.pos.y - opponent.pos.y); if (dist <= 4) { showToast('ìƒëŒ€ë°©ì´ ë„ˆë¬´ ê°€ê¹ìŠµë‹ˆë‹¤!', 'bg-gray-500'); success = false; } else { showToast('ìì„ ë°œë™! ìƒëŒ€ë°©ì„ ëŒì–´ì˜µë‹ˆë‹¤!', 'bg-blue-700'); let stepsToPull = dist - 4; let opponentNewPos = { ...opponent.pos }; while (stepsToPull > 0) { const dx = me.pos.x - opponentNewPos.x; const dy = me.pos.y - opponentNewPos.y; if (Math.abs(dx) > Math.abs(dy)) { opponentNewPos.x += Math.sign(dx); } else { opponentNewPos.y += Math.sign(dy); } stepsToPull--; } opponent.pos = opponentNewPos; } break;
                    case 'encore': showToast('ì•µì½œ! í„´ì„ í•œ ë²ˆ ë” ì§„í–‰í•©ë‹ˆë‹¤!', 'bg-pink-500'); isEncoreActive = true; break;
                    case 'knight': showToast('ë‚˜ì´íŠ¸ ì´ë™! ì´ë™í•  ìœ„ì¹˜ë¥¼ ì„ íƒí•˜ì„¸ìš”.', 'bg-gray-700'); isKnightMoveActive = true; me.pieceEl.innerHTML = 'â™'; success = false; const cardIdx = me.cards.indexOf(selectedCard); if (cardIdx > -1) me.cards.splice(cardIdx, 1); renderPlayerCards(); break;
                    case 'gigantify': showToast('ê±°ëŒ€í™”! 1í„´ê°„ 2x2 ì˜ì—­ìœ¼ë¡œ í™•ì¥ë©ë‹ˆë‹¤.', 'bg-yellow-500'); me.isGigantified = true; break;
                    case 'rewind': if(me.previousPos) { showToast('ë„ë¥´ë§ˆë¬´! ì´ì „ ìœ„ì¹˜ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.', 'bg-orange-500'); newPos = { ...me.previousPos }; } else { showToast('ë˜ëŒì•„ê°ˆ ìœ„ì¹˜ê°€ ì—†ìŠµë‹ˆë‹¤.', 'bg-gray-500'); success = false; } break;
                }
            }
            if (!success) { selectCard(selectedCardElement, selectedCard); return; }

            newPos.x = Math.max(GRID_MIN, Math.min(GRID_MAX, newPos.x)); newPos.y = Math.max(GRID_MIN, Math.min(GRID_MAX, newPos.y));
            targetPlayer.pos = newPos; 
            if (selectedCard.value !== 'knight') { const cardIndex = targetPlayer.cards.indexOf(selectedCard); if (cardIndex > -1) targetPlayer.cards.splice(cardIndex, 1); }
            if (!isDebugMode) cardsUsedThisTurn++;
            elementToRemove.classList.add('card-use-animation'); const pieceEl = (gameMode === 'practice') ? player1Piece : targetPlayer.pieceEl;
            pieceEl.style.transition = 'all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
            pieceEl.style.transform = `scale(${targetPlayer.isGigantified ? 2.4 : 1.2}) rotate(-10deg)`;
            setTimeout(() => { 
                pieceEl.style.transform = `scale(${targetPlayer.isGigantified ? 2 : 1}) ${targetPlayer.isGigantified ? 'translate(-25%, -25%)' : ''}`;
                checkWinCondition(); 
            }, 600);
            selectedCard = null; selectedCardElement = null; updateUI();
        }

        function discardCard() { if (!selectedCardElement) return; const elementToRemove = selectedCardElement; const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId]; const cardIndex = targetPlayer.cards.indexOf(selectedCard); if (cardIndex > -1) targetPlayer.cards.splice(cardIndex, 1); elementToRemove.style.transition = 'transform 0.3s, opacity 0.3s'; elementToRemove.style.transform = 'scale(0.8)'; elementToRemove.style.opacity = '0'; setTimeout(() => { renderPlayerCards(); }, 300); selectedCard = null; selectedCardElement = null; updateButtons(); }

        function endTurn() {
            stopTurnTimer();
            if (isEncoreActive) { isEncoreActive = false; cardsUsedThisTurn = 0; quizSolvedThisTurn = false; quizBtn.disabled = false; updateUI(); startTurnTimer(); showToast(`${players[currentPlayerId].name}ì˜ ì•µì½œ í„´!`, 'bg-pink-500'); return; }
            const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
            if (targetPlayer.isGigantified) { targetPlayer.isGigantified = false; }
            let excess = 0;
            if (targetPlayer.cards.length > MAX_HAND_SIZE) {
                excess = targetPlayer.cards.length - MAX_HAND_SIZE;
                targetPlayer.cards.splice(0, excess);
                showToast(`ì¹´ë“œê°€ 6ì¥ì„ ì´ˆê³¼í•˜ì—¬, ê°€ì¥ ì˜¤ë˜ëœ ì¹´ë“œ ${excess}ì¥ì„ ë²„ë¦½ë‹ˆë‹¤.`, 'bg-orange-500');
            }

            const turnEndAction = () => {
                cardsUsedThisTurn = 0; quizSolvedThisTurn = false; quizBtn.disabled = false; 
                if (gameMode === 'practice') { currentTurn++; drawNewCards(2, null); } 
                else { 
                    if (currentPlayerId === 'p2') {
                        currentTurn++;
                        drawNewCards(2, 'p1');
                        drawNewCards(2, 'p2');
                    }
                    currentPlayerId = (currentPlayerId === 'p1') ? 'p2' : 'p1'; 
                }
                updateUI(); showToast(`${gameMode === 'pvp' ? players[currentPlayerId].name : ''} í„´ ì‹œì‘!`, 'bg-indigo-500'); 
                startTurnTimer();
            };
            
            setTimeout(turnEndAction, excess > 0 ? 1000 : 0);
        }
        
        function checkWinCondition() { 
            if (gameMode === 'practice') { if (practicePlayer.pos.x === practicePlayer.targetPos.x && practicePlayer.pos.y === practicePlayer.targetPos.y) { showToast(`ğŸ‰ ëª©í‘œ ë‹¬ì„±! ${currentTurn}í„´ ë§Œì— ì„±ê³µ!`, 'bg-green-500', 3000); stopTurnTimer(); setTimeout(newGame, 3500); } } 
            else { 
                const p1 = players.p1; const p2 = players.p2; let winnerId = null;
                const p1Hitbox = p1.isGigantified ? [{x:p1.pos.x, y:p1.pos.y}, {x:p1.pos.x-1, y:p1.pos.y}, {x:p1.pos.x, y:p1.pos.y+1}, {x:p1.pos.x-1, y:p1.pos.y+1}] : [p1.pos];
                const p2Hitbox = p2.isGigantified ? [{x:p2.pos.x, y:p2.pos.y}, {x:p2.pos.x-1, y:p2.pos.y}, {x:p2.pos.x, y:p2.pos.y+1}, {x:p2.pos.x-1, y:p2.pos.y+1}] : [p2.pos];
                
                for (const h1 of p1Hitbox) { for (const h2 of p2Hitbox) { if (h1.x === h2.x && h1.y === h2.y) { winnerId = currentPlayerId; break; } } if (winnerId) break; }

                if (winnerId) { 
                    const winner = players[winnerId]; 
                    nextRoundStarterId = winnerId === 'p1' ? 'p2' : 'p1';
                    pvpScores[winnerId]++; 
                    updateScoreboard(); 
                    showToast(`ğŸ‰ ${winner.name} ìŠ¹ë¦¬!`, 'bg-green-500', 3000); 
                    stopTurnTimer(); 
                    setTimeout(newGame, 3500); 
                }
            } 
        }

        function showQuiz() { if (quizSolvedThisTurn) { showToast('í€´ì¦ˆëŠ” í„´ ë‹¹ í•œ ë²ˆë§Œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'bg-orange-500'); return; } currentQuiz = generateQuizData(); document.getElementById('quizQuestion').innerHTML = currentQuiz.question.replace(/\n/g, '<br>'); const optionsContainer = document.getElementById('quizOptions'); optionsContainer.innerHTML = ''; currentQuiz.options.forEach((option, index) => { const label = document.createElement('label'); label.className = "flex items-center p-3 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50 transition"; label.innerHTML = `<input type="radio" name="quiz" value="${index}" class="mr-3 h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"><span>${option}</span>`; optionsContainer.appendChild(label); }); quizModal.classList.remove('hidden'); quizModal.classList.add('flex'); let timeLeft = 30; if (isDebugMode) return; const timerEl = document.getElementById('quizTimer'); timerEl.textContent = timeLeft; quizTimerInterval = setInterval(() => { timeLeft--; timerEl.textContent = timeLeft; if (timeLeft <= 0) { clearInterval(quizTimerInterval); showToast('ì‹œê°„ ì´ˆê³¼! ì¹´ë“œë¥¼ ì–»ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.', 'bg-red-500'); quizSolvedThisTurn = true; quizBtn.disabled = true; closeQuiz(); } }, 1000); }
        function submitQuiz() { const selected = document.querySelector('input[name="quiz"]:checked'); if (!selected) { showToast('ë‹µì„ ì„ íƒí•´ì£¼ì„¸ìš”!', 'bg-red-500'); return; } clearInterval(quizTimerInterval); quizSolvedThisTurn = true; quizBtn.disabled = true; if (parseInt(selected.value) === currentQuiz.correctIndex) { const rand = Math.random(); if (rand < 0.3) { showToast('ì •ë‹µ! ë ˆì–´ ì¹´ë“œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!', 'bg-yellow-400'); addCardToHand(rareCardDeck[Math.floor(Math.random() * rareCardDeck.length)]); } else { showToast('ì •ë‹µ! íŠ¹ìˆ˜ ì¹´ë“œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!', 'bg-green-500'); addCardToHand(specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]); } } else { showToast(`ì˜¤ë‹µì…ë‹ˆë‹¤! ì •ë‹µì€ ${currentQuiz.options[currentQuiz.correctIndex]} ì…ë‹ˆë‹¤.`, 'bg-orange-500', 4000); } closeQuiz(); }
        function closeQuiz() { clearInterval(quizTimerInterval); quizModal.classList.add('hidden'); quizModal.classList.remove('flex'); }
        const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min; const getRandomNonZeroInt = (min, max) => { let num; do { num = getRandomInt(min, max); } while (num === 0); return num; }; function formatLine(m, b) { let str = 'y = '; if (m === 1) str += 'x'; else if (m === -1) str += '-x'; else if (m !== 0) str += `${m}x`; if (b > 0) str += (m !== 0 ? ' + ' : '') + `${b}`; else if (b < 0) str += ` - ${-b}`; if (m === 0 && b === 0) return 'y = 0'; return str; } function formatCircle(h, k, r) { let str = ''; if (h === 0) str += 'xÂ²'; else str += `(x ${h > 0 ? '-' : '+'} ${Math.abs(h)})Â²`; str += ' + '; if (k === 0) str += 'yÂ²'; else str += `(y ${k > 0 ? '-' : '+'} ${Math.abs(k)})Â²`; str += ` = ${r*r}`; return str; } function generateQuizData() { const type = getRandomInt(0, 3); switch (type) { case 0: return generateTranslateLineQuiz(); case 1: return generateReflectLineQuiz(); case 2: return generateTranslateCircleQuiz(); case 3: return generateReflectCircleQuiz(); } } function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; } function generateTranslateLineQuiz() { const m = getRandomNonZeroInt(-2, 2), b = getRandomInt(-3, 3), dx = getRandomNonZeroInt(-3, 3), dy = getRandomNonZeroInt(-3, 3); const question = `ì§ì„  ${formatLine(m, b)}ë¥¼\nxì¶• ë°©í–¥ìœ¼ë¡œ ${dx}ë§Œí¼, yì¶• ë°©í–¥ìœ¼ë¡œ ${dy}ë§Œí¼\ní‰í–‰ì´ë™í•œ ë°©ì •ì‹ì€?`; const correct = formatLine(m, -m * dx + b + dy); const distractors = [ formatLine(m, m * dx + b - dy), formatLine(m, -m * dx + b - dy), formatLine(m, m * dx + b + dy) ]; const options = shuffle([correct, ...new Set(distractors.filter(d => d !== correct))].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateReflectLineQuiz() { const m = getRandomInt(0,1) === 0 ? 1 : -1, b = getRandomInt(-3, 3); const types = ['xì¶•', 'yì¶•', 'ì›ì ', 'ì§ì„  y=x'], type = types[getRandomInt(0, 3)]; const question = `ì§ì„  ${formatLine(m, b)}ë¥¼\n${type}ì— ëŒ€ì¹­ì´ë™í•œ ë°©ì •ì‹ì€?`; let correct, distractors; if (type === 'xì¶•') { correct = formatLine(-m, -b); distractors = [formatLine(-m, b), formatLine(m, -b), formatLine(m, b), formatLine(1/m, b)]; } else if (type === 'yì¶•') { correct = formatLine(-m, b); distractors = [formatLine(-m, -b), formatLine(m, -b), formatLine(m, b), formatLine(1/m, -b)]; } else if (type === 'ì›ì ') { correct = formatLine(m, -b); distractors = [formatLine(-m, -b), formatLine(-m, b), formatLine(m, b), formatLine(-1/m, b)]; } else { correct = formatLine(1/m, -b/m); distractors = [formatLine(m, b), formatLine(-m, b), formatLine(m, -b), formatLine(-m, -b)]; } const options = shuffle([correct, ...new Set(distractors.filter(d => d !== correct))].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateTranslateCircleQuiz() { const h = getRandomInt(-3, 3), k = getRandomInt(-3, 3), r = getRandomInt(1, 4), dx = getRandomNonZeroInt(-3, 3), dy = getRandomNonZeroInt(-3, 3); const question = `ì› ${formatCircle(h, k, r)}ë¥¼\nxì¶• ë°©í–¥ìœ¼ë¡œ ${dx}ë§Œí¼, yì¶• ë°©í–¥ìœ¼ë¡œ ${dy}ë§Œí¼\ní‰í–‰ì´ë™í•œ ë°©ì •ì‹ì€?`; const correct = formatCircle(h + dx, k + dy, r); const distractors = [ formatCircle(h - dx, k - dy, r), formatCircle(h + dx, k + dy, r + 1), formatCircle(h, k, r) ]; const options = shuffle([correct, ...new Set(distractors)].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateReflectCircleQuiz() { const h = getRandomInt(-3, 3), k = getRandomInt(-3, 3), r = getRandomInt(1, 4); const types = ['xì¶•', 'yì¶•', 'ì›ì ', 'ì§ì„  y=x'], type = types[getRandomInt(0, 3)]; const question = `ì› ${formatCircle(h, k, r)}ë¥¼\n${type}ì— ëŒ€ì¹­ì´ë™í•œ ë°©ì •ì‹ì€?`; let correct, distractors; if (type === 'xì¶•') { correct = formatCircle(h, -k, r); distractors = [formatCircle(-h, k, r), formatCircle(h, k, r), formatCircle(h, -k, r+1)]; } else if (type === 'yì¶•') { correct = formatCircle(-h, k, r); distractors = [formatCircle(h, -k, r), formatCircle(h, k, r), formatCircle(-h, k, r+1)]; } else if (type === 'ì›ì ') { correct = formatCircle(-h, -k, r); distractors = [formatLine(h, -k, r), formatCircle(-h, k, r), formatCircle(-h, -k, r+1)]; } else { correct = formatCircle(k, h, r); distractors = [formatCircle(-k, -h, r), formatCircle(h, k, r), formatCircle(k, h, r+1)]; } const options = shuffle([correct, ...new Set(distractors)].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; }

        function coordToPixel(pos) { const boardSize = gameBoard.clientWidth, unit = boardSize / (GRID_SIZE + 1); return { left: (pos.x - GRID_MIN) * unit + unit / 2 - 36 / 2, top: (GRID_MAX - pos.y) * unit + unit / 2 - 36 / 2 }; }
        function updateAllPiecePositions() { if (gameMode === 'practice') { const practicePos = coordToPixel(practicePlayer.pos); player1Piece.style.left = `${practicePos.left}px`; player1Piece.style.top = `${practicePos.top}px`; const targetPos = coordToPixel(practicePlayer.targetPos); targetGoal.style.left = `${targetPos.left + 4}px`; targetGoal.style.top = `${targetPos.top + 4}px`; } else { const p1Pos = coordToPixel(players.p1.pos); player1Piece.style.left = `${p1Pos.left}px`; player1Piece.style.top = `${p1Pos.top}px`; const p2Pos = coordToPixel(players.p2.pos); player2Piece.style.left = `${p2Pos.left}px`; player2Piece.style.top = `${p2Pos.top}px`; } }
        function updateUI() { updateAllPiecePositions(); renderPlayerCards(); if(gameMode === 'pvp') { renderOpponentCards(); players.p1.gigantifiedEl.classList.toggle('hidden', !players.p1.isGigantified); players.p2.gigantifiedEl.classList.toggle('hidden', !players.p2.isGigantified); if(players.p1.isGigantified) { const gPos = coordToPixel({x: players.p1.pos.x - 1, y: players.p1.pos.y + 1}); const gSize = (gameBoard.clientWidth / (GRID_SIZE + 1)) * 2; players.p1.gigantifiedEl.style.left = `${gPos.left}px`; players.p1.gigantifiedEl.style.top = `${gPos.top}px`; players.p1.gigantifiedEl.style.width = `${gSize}px`; players.p1.gigantifiedEl.style.height = `${gSize}px`; players.p1.pieceEl.style.transform = `scale(2) translate(-25%, -25%)`; } else { players.p1.pieceEl.style.transform = 'scale(1)'; } if(players.p2.isGigantified) { const gPos = coordToPixel({x: players.p2.pos.x - 1, y: players.p2.pos.y + 1}); const gSize = (gameBoard.clientWidth / (GRID_SIZE + 1)) * 2; players.p2.gigantifiedEl.style.left = `${gPos.left}px`; players.p2.gigantifiedEl.style.top = `${gPos.top}px`; players.p2.gigantifiedEl.style.width = `${gSize}px`; players.p2.gigantifiedEl.style.height = `${gSize}px`; players.p2.pieceEl.style.transform = `scale(2) translate(-25%, -25%)`; } else { players.p2.pieceEl.style.transform = 'scale(1)'; } } turnDisplayEl.textContent = `í„´ ${currentTurn}`; if (gameMode === 'practice') { infoPanelTitle.textContent = 'ê²Œì„ ì •ë³´'; turnIndicator.textContent = 'ì—°ìŠµ ëª¨ë“œ'; infoPanelContent.innerHTML = `<div class="flex justify-between items-center"><span class="text-gray-600">í˜„ì¬ ìœ„ì¹˜:</span><span class="font-semibold text-blue-600 text-lg">(${practicePlayer.pos.x}, ${practicePlayer.pos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">ëª©í‘œ ì§€ì :</span><span class="font-semibold text-green-600 text-lg">(${practicePlayer.targetPos.x}, ${practicePlayer.targetPos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">ë‚¨ì€ ê±°ë¦¬:</span><span class="font-semibold text-red-500 text-lg">${Math.abs(practicePlayer.pos.x - practicePlayer.targetPos.x) + Math.abs(practicePlayer.pos.y - practicePlayer.targetPos.y)} ì¹¸</span></div>`; } else { const currentPlayer = players[currentPlayerId]; const opponentPlayer = players[currentPlayerId === 'p1' ? 'p2' : 'p1']; infoPanelTitle.textContent = `${currentPlayer.character} ${currentPlayer.name}`; infoPanelTitle.className = `text-xl font-bold mb-4 ${currentPlayerId === 'p1' ? 'text-cyan-600' : 'text-purple-600'}`; turnIndicator.textContent = `PvP ëª¨ë“œ`; infoPanelContent.innerHTML = `<div class="flex justify-between items-center"><span class="text-gray-600">ë‚˜ì˜ ìœ„ì¹˜:</span><span class="font-semibold text-blue-600 text-lg">(${currentPlayer.pos.x}, ${currentPlayer.pos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">ìƒëŒ€ ìœ„ì¹˜:</span><span class="font-semibold text-red-500 text-lg">(${opponentPlayer.pos.x}, ${opponentPlayer.pos.y})</span></div>`; } updateButtons(); }
        function updateScoreboard() { p1ScoreEl.textContent = pvpScores.p1; p2ScoreEl.textContent = pvpScores.p2; }
        function updateButtons() { useCardBtn.textContent = `ì¹´ë“œ ì‚¬ìš© (${isDebugMode ? 'âˆ' : cardsUsedThisTurn + '/' + MAX_CARDS_PER_TURN})`; useCardBtn.disabled = !selectedCard || (!isDebugMode && cardsUsedThisTurn >= MAX_CARDS_PER_TURN); discardCardBtn.disabled = !selectedCard; quizBtn.disabled = quizSolvedThisTurn; }
        function showToast(message, bgColor, duration = 3000) { const toast = document.createElement('div'); toast.textContent = message; toast.className = `toast-notification ${bgColor}`; document.getElementById('toastContainer').appendChild(toast); setTimeout(() => { toast.style.opacity = '1'; toast.style.top = '40px'; }, 10); setTimeout(() => { toast.style.opacity = '0'; toast.style.top = '20px'; setTimeout(() => toast.remove(), 500); }, duration); }

        // --- í„´ íƒ€ì´ë¨¸ ê¸°ëŠ¥ ---
        function startTurnTimer() { if (isDebugMode || gameMode === 'practice') { turnTimerContainer.classList.add('hidden'); return; } turnTimerContainer.classList.remove('hidden'); stopTurnTimer(); let timeLeft = TURN_TIME_LIMIT; turnTimerBar.style.width = '100%'; turnTimerInterval = setInterval(() => { timeLeft--; const percentage = (timeLeft / TURN_TIME_LIMIT) * 100; turnTimerBar.style.width = `${percentage}%`; if (timeLeft <= 0) { showToast('ì‹œê°„ ì´ˆê³¼! í„´ì´ ìë™ìœ¼ë¡œ ì¢…ë£Œë©ë‹ˆë‹¤.', 'bg-red-500'); endTurn(); } }, 1000); }
        function stopTurnTimer() { clearInterval(turnTimerInterval); }
        
        // --- ë‚˜ì´íŠ¸ ê¸°ëŠ¥ ---
        function handleBoardClick(e) {
            const rect = gameBoard.getBoundingClientRect(); const unit = gameBoard.clientWidth / (GRID_SIZE + 1);
            const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top;
            const targetCoord = { x: Math.round((clickX - unit/2) / unit) + GRID_MIN, y: GRID_MAX - Math.round((clickY - unit/2) / unit) };
            
            if (isKnightMoveActive) {
                const me = players[currentPlayerId];
                const dx = Math.abs(targetCoord.x - me.pos.x);
                const dy = Math.abs(targetCoord.y - me.pos.y);
                if ((dx === 1 && dy === 2) || (dx === 2 && dy === 1)) {
                    me.previousPos = { ...me.pos };
                    me.pos = targetCoord;
                    isKnightMoveActive = false;
                    me.pieceEl.innerHTML = me.character;
                    if (!isDebugMode) cardsUsedThisTurn++;
                    selectedCard = null; selectedCardElement = null;
                    updateUI();
                    checkWinCondition();
                } else {
                    showToast('ë‚˜ì´íŠ¸ê°€ ì´ë™í•  ìˆ˜ ì—†ëŠ” ìœ„ì¹˜ì…ë‹ˆë‹¤.', 'bg-orange-500');
                }
            } else if (isDebugMode) {
                const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
                targetPlayer.pos = targetCoord;
                updateUI(); showToast(`ìˆœê°„ì´ë™: (${targetCoord.x}, ${targetCoord.y})`, 'bg-red-500');
            }
        }
        
        // --- ë””ë²„ê·¸ ê¸°ëŠ¥ ---
        function toggleSummonList() { summonListModal.classList.toggle('hidden'); summonListModal.classList.toggle('flex'); if (!summonListModal.classList.contains('hidden')) { populateSummonList(); } }
        function populateSummonList() {
            summonListContainer.innerHTML = '';
            const allCards = [...cardDeck, ...specialCardDeck, ...rareCardDeck];
            allCards.forEach(card => {
                const cardEl = createCardElement(card, false);
                cardEl.onclick = () => {
                    addCardToHand(card);
                    toggleSummonList();
                };
                summonListContainer.appendChild(cardEl);
            });
        }

        // --- ë£°ë¶ ê¸°ëŠ¥ ---
        function showRulebook() {
            rulebookContent.innerHTML = `
                <h3 class="text-xl font-bold mb-2">ê²Œì„ ì»¨ì…‰</h3>
                <p class="mb-4">ì´ ê²Œì„ì€ ì¢Œí‘œí‰ë©´ ìœ„ì—ì„œ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ìì‹ ì˜ ë§ì„ ì›€ì§ì—¬ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ëŠ” ì „ëµ ë³´ë“œê²Œì„ì…ë‹ˆë‹¤. ìˆ˜í•™ì  ì‚¬ê³ ë ¥ê³¼ ì „ëµì  íŒë‹¨ë ¥ì„ ë™ì‹œì— ìš”êµ¬í•©ë‹ˆë‹¤.</p>
                
                <h3 class="text-xl font-bold mb-2">ê²Œì„ ëª¨ë“œ</h3>
                <ul class="list-disc list-inside mb-4">
                    <li><b>ì—°ìŠµ ëª¨ë“œ:</b> í˜¼ìì„œ ëª©í‘œ ì§€ì (ğŸ¯)ì— ë„ë‹¬í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤. ê²Œì„ì˜ ê¸°ë³¸ì ì¸ ê·œì¹™ê³¼ ì¹´ë“œ ì‚¬ìš©ë²•ì„ ìµíˆê¸°ì— ì¢‹ìŠµë‹ˆë‹¤.</li>
                    <li><b>PvP ëª¨ë“œ:</b> ë‘ ëª…ì˜ í”Œë ˆì´ì–´ê°€ ìƒëŒ€ë°©ì˜ ë§ì„ ì¡ê¸° ìœ„í•´ ê²½ìŸí•©ë‹ˆë‹¤. ìì‹ ì˜ í„´ì— ìƒëŒ€ë°©ê³¼ ê°™ì€ ì¹¸ì— ë„ì°©í•˜ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</li>
                </ul>

                <h3 class="text-xl font-bold mb-2">ê²Œì„ ì§„í–‰</h3>
                <ul class="list-disc list-inside mb-4">
                    <li>ìì‹ ì˜ í„´ì— ìµœëŒ€ 2ì¥ì˜ ì¹´ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                    <li>'í€´ì¦ˆ ë„ì „' ë²„íŠ¼ì„ ëˆŒëŸ¬ ìˆ˜í•™ í€´ì¦ˆë¥¼ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (í„´ ë‹¹ 1íšŒ)</li>
                    <li>í€´ì¦ˆë¥¼ ë§íˆë©´ 'íŠ¹ìˆ˜ ì¹´ë“œ'(70%) ë˜ëŠ” 'ë ˆì–´ ì¹´ë“œ'(30%)ë¥¼ ë³´ìƒìœ¼ë¡œ ì–»ìŠµë‹ˆë‹¤.</li>
                    <li>ì†ì— ë“¤ ìˆ˜ ìˆëŠ” ì¹´ë“œëŠ” ìµœëŒ€ 6ì¥ì…ë‹ˆë‹¤. í„´ ì¢…ë£Œ ì‹œ 6ì¥ì„ ì´ˆê³¼í•˜ë©´ ê°€ì¥ ì˜¤ë˜ëœ ì¹´ë“œë¶€í„° ìë™ìœ¼ë¡œ ë²„ë ¤ì§‘ë‹ˆë‹¤.</li>
                    <li>PvP ëª¨ë“œì—ì„œëŠ” ê° í„´ë§ˆë‹¤ 2ë¶„ì˜ ì‹œê°„ ì œí•œì´ ìˆìŠµë‹ˆë‹¤.</li>
                </ul>

                <h3 class="text-xl font-bold mb-2">ì¹´ë“œ ë“±ê¸‰</h3>
                <p class="mb-4">ì¹´ë“œëŠ” ì¼ë°˜, íŠ¹ìˆ˜, ë ˆì–´ ì„¸ ê°€ì§€ ë“±ê¸‰ìœ¼ë¡œ ë‚˜ë‰©ë‹ˆë‹¤.</p>
                <ul class="list-disc list-inside mb-4">
                    <li><b>ì¼ë°˜ ì¹´ë“œ (í°ìƒ‰):</b> xì¶• ë˜ëŠ” yì¶• ë°©í–¥ìœ¼ë¡œ ë§ì„ ì´ë™ì‹œí‚µë‹ˆë‹¤.</li>
                    <li><b>íŠ¹ìˆ˜ ì¹´ë“œ (í•˜ëŠ˜ìƒ‰):</b> xì¶•, yì¶•, ì›ì  ëŒ€ì¹­ì´ë™ê³¼ ê°™ì€ íŠ¹ë³„í•œ ì›€ì§ì„ì„ ì œê³µí•©ë‹ˆë‹¤.</li>
                    <li><b>ë ˆì–´ ì¹´ë“œ (ë…¸ë€ìƒ‰):</b> ê²Œì„ì˜ íŒë„ë¥¼ ë’¤ì§‘ì„ ìˆ˜ ìˆëŠ” ê°•ë ¥í•˜ê³  í¬ê·€í•œ íš¨ê³¼ë¥¼ ê°€ì§‘ë‹ˆë‹¤.</li>
                </ul>

                <h4 class="text-lg font-bold mt-4 mb-2">ë ˆì–´ ì¹´ë“œ ìƒì„¸ ì„¤ëª…</h4>
                <ul class="list-disc list-inside space-y-2">
                    <li><b>ì €ê²©ì´:</b> ìì‹ ì˜ ë§ê³¼ ìƒëŒ€ë°©ì˜ ë§ì´ ê°™ì€ ê°€ë¡œì¤„ì´ë‚˜ ì„¸ë¡œì¤„ì— ìˆì„ ë•Œ, ì¦‰ì‹œ ìƒëŒ€ë°©ì„ ì¡ì•„ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</li>
                    <li><b>ë¹„ìƒíƒˆì¶œ:</b> ë‘ í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ ë§µ ìœ„ì˜ ë¬´ì‘ìœ„ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì¬ì„¤ì •í•©ë‹ˆë‹¤.</li>
                    <li><b>ìì„:</b> ìƒëŒ€ë°©ì„ ìì‹ ì˜ ë§ ìª½ìœ¼ë¡œ ëŒì–´ë‹¹ê²¨, ë‘˜ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ 4ì¹¸ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤. (4ì¹¸ ì´í•˜ì¼ ê²½ìš° ì‚¬ìš© ë¶ˆê°€)</li>
                    <li><b>ì•µì½œ:</b> ì´ë²ˆ í„´ì„ ë§ˆì¹œ ë’¤, ìƒëŒ€ë°©ì—ê²Œ í„´ì„ ë„˜ê¸°ì§€ ì•Šê³  ìì‹ ì˜ í„´ì„ í•œ ë²ˆ ë” ì§„í–‰í•©ë‹ˆë‹¤.</li>
                    <li><b>ë‚˜ì´íŠ¸:</b> ë§ì„ ì²´ìŠ¤ ë‚˜ì´íŠ¸(â™)ì²˜ëŸ¼ í•œ ì¹¸ ì´ë™ì‹œí‚µë‹ˆë‹¤.</li>
                    <li><b>ê±°ëŒ€í™”:</b> 1í„´ê°„ ìì‹ ì˜ ë§ì´ 2x2 ì˜ì—­ì„ ì°¨ì§€í•˜ê²Œ ë©ë‹ˆë‹¤. ì´ ì˜ì—­ì— ìƒëŒ€ë°©ì´ ë‹¿ìœ¼ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤.</li>
                    <li><b>ë„ë¥´ë§ˆë¬´:</b> ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ê¸° ì „ì˜ ìœ„ì¹˜ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.</li>
                </ul>
            `;
            rulebookModal.classList.remove('hidden');
            rulebookModal.classList.add('flex');
        }
        function hideRulebook() {
            rulebookModal.classList.add('hidden');
            rulebookModal.classList.remove('flex');
        }
    </script>
</body>
</html>