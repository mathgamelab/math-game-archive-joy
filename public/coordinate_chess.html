<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>좌표평면 체스</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;600;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; overscroll-behavior: none; }
        .grid-dot { width: 5px; height: 5px; background: #a0aec0; border-radius: 50%; }
        .card-container { -ms-overflow-style: none; scrollbar-width: none; scroll-behavior: smooth; }
        .card-container::-webkit-scrollbar { display: none; }
        .card-hover { transition: transform 0.3s ease, box-shadow 0.3s ease; }
        .card-hover:hover:not(.card-selected) { transform: translateY(-8px); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        .card-selected { transform: translateY(-20px) scale(1.03); box-shadow: 0 25px 50px -12px rgba(59, 130, 246, 0.25); border: 2px solid #3b82f6; }
        .player-piece { 
            transition: all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55); 
            transform-origin: center;
        }
        .quiz-overlay, .debug-overlay, .rulebook-overlay { backdrop-filter: blur(8px); background: rgba(17, 24, 39, 0.6); }
        .axis-line { background: #9ca3af; }
        @keyframes cardUse { 0% { transform: translateY(0) scale(1); opacity: 1; } 50% { transform: translateY(-40px) scale(1.1); opacity: 1; } 100% { transform: translateY(-80px) scale(0.5) rotate(15deg); opacity: 0; } }
        .card-use-animation { animation: cardUse 0.7s ease-out forwards; }
        .toast-notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 9999px; color: white; font-weight: 600; z-index: 1000; opacity: 0; transition: opacity 0.5s, top 0.5s; }
        .mode-select-button { transition: all 0.2s ease-in-out; }
        .mode-select-button:hover { transform: scale(1.05); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); }
        #turnTimerBar { transition: width 1s linear; }
        .gigantified-effect {
            position: absolute;
            background-color: rgba(255, 235, 59, 0.3);
            border: 2px dashed #FBBF24;
            border-radius: 10px;
            z-index: 29;
            pointer-events: none;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">

    <div id="modeSelectionScreen" class="w-full max-w-md p-8 bg-white rounded-2xl shadow-2xl text-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-2">좌표평면 체스♞</h1>
        <p class="text-gray-500 mb-8">플레이할 모드를 선택하세요.</p>
        <div class="space-y-4">
            <button onclick="startGame('practice')" class="mode-select-button w-full bg-cyan-500 hover:bg-cyan-600 text-white py-4 rounded-lg font-semibold text-lg">🚀 연습 모드 (혼자하기)</button>
            <button onclick="startGame('pvp')" class="mode-select-button w-full bg-purple-500 hover:bg-purple-600 text-white py-4 rounded-lg font-semibold text-lg">🛸 PvP 모드 (둘이하기)</button>
        </div>
        <div class="mt-10 text-center text-sm text-gray-400">
            <p>행복한 수학, 함께 만들어요! 😊</p>
            <p>© 행복한윤쌤 | <a href="https://blog.naver.com/happy_yoonssam" target="_blank" class="hover:underline text-gray-500">https://blog.naver.com/happy_yoonssam</a></p>
        </div>
    </div>

    <div id="gameContainer" class="hidden w-full h-screen flex-col sm:flex-row relative">
        <div class="absolute top-4 right-4 flex gap-2 z-20">
             <button id="rulebookBtn" title="룰북 보기" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-200 transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
             </button>
             <button onclick="exitToMenu()" title="메인 메뉴로 돌아가기" class="bg-white p-2 rounded-full shadow-md hover:bg-gray-200 transition"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></button>
        </div>
        
        <div id="opponentHandContainer" class="absolute top-2 left-4 flex items-center gap-2 z-10"></div>

        <div id="mainContentArea" class="flex flex-1 w-full max-w-screen-2xl mx-auto overflow-hidden">
            <div class="flex-1 p-4 sm:p-6 flex justify-center pt-16">
                <div class="relative w-full h-full max-w-[440px] max-h-[440px] sm:max-w-[520px] sm:max-h-[520px] aspect-square">
                    <div id="gameBoard" class="bg-white border-2 border-gray-200 rounded-lg shadow-lg w-full h-full relative">
                        <div class="axis-line absolute w-full h-0.5" style="top: 50%; left: 0;"></div>
                        <div id="xAxisLabel" class="absolute cursor-pointer" style="right: -18px; top: 50%; transform: translateY(-50%);"><div class="flex items-center"><div style="width: 0; height: 0; border-left: 8px solid #4b5563; border-top: 5px solid transparent; border-bottom: 5px solid transparent;"></div><span class="ml-1 text-base font-bold text-gray-700">X</span></div></div>
                        <div class="axis-line absolute h-full w-0.5" style="left: 50%; top: 0;"></div>
                        <div id="yAxisLabel" class="absolute cursor-pointer" style="left: 50%; top: -24px; transform: translateX(-50%);"><div class="flex flex-col items-center"><div style="width: 0; height: 0; border-bottom: 8px solid #4b5563; border-left: 5px solid transparent; border-right: 5px solid transparent;"></div><span class="mt-1 text-base font-bold text-gray-700">Y</span></div></div>
                        <div id="gridDots" class="absolute inset-0"></div>
                        <div id="axisLabels" class="absolute inset-0"></div>
                        <div id="player1Gigantified" class="gigantified-effect hidden"></div>
                        <div id="player2Gigantified" class="gigantified-effect hidden"></div>
                        <div id="player1Piece" class="player-piece absolute flex items-center justify-center" style="width: 36px; height: 36px; z-index: 30; font-size: 28px;">🚀</div>
                        <div id="player2Piece" class="player-piece absolute hidden items-center justify-center" style="width: 36px; height: 36px; z-index: 30; font-size: 28px;">🛸</div>
                        <div id="targetGoal" class="absolute bg-green-400 rounded-full shadow-lg flex items-center justify-center text-white font-bold" style="width: 28px; height: 28px; z-index: 5;">🎯</div>
                    </div>
                </div>
            </div>
            <div id="rightPanel" class="w-full sm:w-80 bg-gray-50 p-4 sm:p-6 flex flex-col border-l border-gray-200">
                <div id="infoPanel" class="bg-white rounded-xl shadow p-5 mb-6"><h2 id="infoPanelTitle" class="text-xl font-bold text-gray-800 mb-4">게임 정보</h2><div id="infoPanelContent" class="space-y-3"></div></div>
                <div id="scoreboard" class="hidden bg-white rounded-xl shadow p-5 mb-6"><h2 class="text-xl font-bold text-gray-800 mb-4">스코어</h2><div class="space-y-3"><div class="flex justify-between items-center text-lg"><span class="font-semibold text-cyan-600">🚀 Player 1</span><span id="p1Score" class="font-bold text-gray-800">0</span></div><div class="flex justify-between items-center text-lg"><span class="font-semibold text-purple-600">🛸 Player 2</span><span id="p2Score" class="font-bold text-gray-800">0</span></div></div></div>
                <div id="debugPanel" class="hidden bg-red-100 border border-red-300 rounded-xl p-5 mb-6"><h2 class="text-xl font-bold text-red-700 mb-4">디버그 메뉴</h2><div class="grid grid-cols-1 gap-3"><button id="summonCardBtn" class="w-full bg-red-500 hover:bg-red-600 text-white py-2 rounded-lg font-semibold">카드 소환</button></div></div>
                <div class="bg-white rounded-xl shadow p-5"><div class="flex justify-between items-center mb-4"><span id="turnIndicator" class="text-gray-600"></span><span class="text-2xl font-bold text-indigo-600" id="turnDisplay">턴 1</span></div><div class="grid grid-cols-1 gap-3"><button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-3 rounded-lg font-semibold shadow-md transition-all" onclick="endTurn()">턴 종료</button></div><div id="turnTimerContainer" class="w-full bg-gray-200 rounded-full h-2.5 mt-4"><div id="turnTimerBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 100%"></div></div></div>
            </div>
        </div>
        <div id="bottomPanel" class="fixed bottom-0 left-0 right-0 bg-white/80 backdrop-blur-sm border-t-2 border-gray-200 p-4 sm:p-6 z-10">
            <div class="max-w-7xl mx-auto flex items-center gap-x-4 sm:gap-x-6">
                <div id="cardContainer" class="card-container flex-1 flex space-x-4 overflow-x-auto py-2"></div>
                <div class="flex items-center space-x-3 flex-shrink-0">
                    <button id="useCardBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all disabled:opacity-50 disabled:cursor-not-allowed" onclick="useSelectedCard()" disabled>카드<br>사용</button>
                    <button id="discardCardBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all disabled:opacity-50 disabled:cursor-not-allowed" onclick="discardCard()">카드<br>버리기</button>
                    <button id="quizBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-semibold shadow-md transition-all" onclick="showQuiz()">퀴즈<br>도전</button>
                </div>
            </div>
        </div>
    </div>
    <div id="quizModal" class="fixed inset-0 quiz-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full mx-auto"><div class="flex justify-between items-center mb-4"><h3 id="quizTitle" class="text-xl font-bold text-gray-800">도형의 이동 퀴즈</h3><div id="quizTimer" class="text-2xl font-bold text-red-500"></div></div><div id="quizQuestion" class="text-gray-700 mb-4 text-center bg-gray-100 p-4 rounded-lg"></div><div id="quizOptions" class="space-y-3"></div><div class="flex space-x-3 mt-6"><button class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-semibold transition-all" onclick="submitQuiz()">제출</button></div></div></div>
    <div id="summonListModal" class="fixed inset-0 debug-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-2xl w-full mx-auto"><div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold text-gray-800">카드 소환</h3><button id="closeSummonListBtn" class="text-gray-500 hover:text-gray-800">✖</button></div><div id="summonListContainer" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 max-h-96 overflow-y-auto"></div></div></div>
    <div id="rulebookModal" class="fixed inset-0 rulebook-overlay hidden items-center justify-center z-50 p-4"><div class="bg-white rounded-2xl shadow-2xl p-8 max-w-3xl w-full mx-auto h-5/6 flex flex-col"><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold text-gray-800">게임 룰북</h2><button id="closeRulebookBtn" class="text-gray-500 hover:text-gray-800 text-2xl">✖</button></div><div id="rulebookContent" class="prose max-w-none overflow-y-auto"></div></div></div>
    <div id="toastContainer"></div>

    <script>
        // --- 게임 상태 변수 ---
        let gameMode = ''; 
        let players = { 
            p1: { pos: {x: 0, y: 0}, previousPos: null, cards: [], pieceEl: null, gigantifiedEl: null, character: '🚀', name: 'Player 1', isGigantified: false }, 
            p2: { pos: {x: 0, y: 0}, previousPos: null, cards: [], pieceEl: null, gigantifiedEl: null, character: '🛸', name: 'Player 2', isGigantified: false } 
        };
        let practicePlayer = { pos: {x: 0, y: 0}, targetPos: {x: 0, y: 0}, cards: [], previousPos: null }; 
        let pvpScores = { p1: 0, p2: 0 }; 
        let currentPlayerId = 'p1';
        let nextRoundStarterId = null;
        let selectedCard = null, selectedCardElement = null; 
        let cardsUsedThisTurn = 0, currentTurn = 1, quizSolvedThisTurn = false; 
        let isDebugMode = false; let isEncoreActive = false; let isKnightMoveActive = false;
        const MAX_CARDS_PER_TURN = 2; const MAX_HAND_SIZE = 6; const TURN_TIME_LIMIT = 120;
        
        // --- 게임 설정 변수 ---
        const GRID_MIN = -5, GRID_MAX = 5, GRID_SIZE = GRID_MAX - GRID_MIN;

        // --- DOM 요소 캐싱 ---
        const gameContainer = document.getElementById('gameContainer'), modeSelectionScreen = document.getElementById('modeSelectionScreen');
        const player1Piece = document.getElementById('player1Piece'), player2Piece = document.getElementById('player2Piece');
        const targetGoal = document.getElementById('targetGoal'); const infoPanelTitle = document.getElementById('infoPanelTitle'), infoPanelContent = document.getElementById('infoPanelContent');
        const scoreboard = document.getElementById('scoreboard'), p1ScoreEl = document.getElementById('p1Score'), p2ScoreEl = document.getElementById('p2Score');
        const turnIndicator = document.getElementById('turnIndicator'), turnDisplayEl = document.getElementById('turnDisplay');
        const useCardBtn = document.getElementById('useCardBtn'), discardCardBtn = document.getElementById('discardCardBtn');
        const cardContainer = document.getElementById('cardContainer'), quizModal = document.getElementById('quizModal');
        const gameBoard = document.getElementById('gameBoard'), quizBtn = document.getElementById('quizBtn');
        const mainContentArea = document.querySelector('#gameContainer > .flex');
        const bottomPanel = document.getElementById('bottomPanel');
        const opponentHandContainer = document.getElementById('opponentHandContainer');
        const xAxisLabel = document.getElementById('xAxisLabel'), yAxisLabel = document.getElementById('yAxisLabel');
        const debugPanel = document.getElementById('debugPanel'); const summonListModal = document.getElementById('summonListModal'); const summonListContainer = document.getElementById('summonListContainer');
        const turnTimerContainer = document.getElementById('turnTimerContainer'), turnTimerBar = document.getElementById('turnTimerBar');
        const rulebookModal = document.getElementById('rulebookModal'); const rulebookContent = document.getElementById('rulebookContent');
        
        // --- 카드 덱 정의 (레어 카드 추가) ---
        const cardDeck = [ { type: 'move', value: { x: 1 }, text: 'X : +1', educationalDesc: 'x축 방향으로<br>1만큼 평행이동', color: 'blue' }, { type: 'move', value: { x: 2 }, text: 'X : +2', educationalDesc: 'x축 방향으로<br>2만큼 평행이동', color: 'blue' }, { type: 'move', value: { x: 3 }, text: 'X : +3', educationalDesc: 'x축 방향으로<br>3만큼 평행이동', color: 'blue' }, { type: 'move', value: { x: -1 }, text: 'X : -1', educationalDesc: 'x축 방향으로<br>-1만큼 평행이동', color: 'orange' }, { type: 'move', value: { x: -2 }, text: 'X : -2', educationalDesc: 'x축 방향으로<br>-2만큼 평행이동', color: 'orange' }, { type: 'move', value: { y: 1 }, text: 'Y : +1', educationalDesc: 'y축 방향으로<br>1만큼 평행이동', color: 'green' }, { type: 'move', value: { y: 2 }, text: 'Y : +2', educationalDesc: 'y축 방향으로<br>2만큼 평행이동', color: 'green' }, { type: 'move', value: { y: 3 }, text: 'Y : +3', educationalDesc: 'y축 방향으로<br>3만큼 평행이동', color: 'green' }, { type: 'move', value: { y: -1 }, text: 'Y : -1', educationalDesc: 'y축 방향으로<br>-1만큼 평행이동', color: 'teal' }, { type: 'move', value: { y: -2 }, text: 'Y : -2', educationalDesc: 'y축 방향으로<br>-2만큼 평행이동', color: 'teal' }, ];
        const specialCardDeck = [ { type: 'special', value: 'origin', text: '원점 대칭', educationalDesc: '원점에 대하여<br>대칭이동', color: 'purple' }, { type: 'special', value: 'x-axis', text: 'X축 대칭', educationalDesc: 'x축에 대하여<br>대칭이동', color: 'red' }, { type: 'special', value: 'y-axis', text: 'Y축 대칭', educationalDesc: 'y축에 대하여<br>대칭이동', color: 'indigo' }, ];
        const rareCardDeck = [ { type: 'rare', value: 'sniper', text: '저격총', educationalDesc: '상대방과 같은 직선에<br>있다면 즉시 추격', color: 'slate' }, { type: 'rare', value: 'emergency_escape', text: '비상탈출', educationalDesc: '모든 플레이어의 위치를<br>무작위로 재설정', color: 'slate' }, { type: 'rare', value: 'magnet', text: '자석', educationalDesc: '상대방을 4칸<br>거리까지 끌어오기', color: 'slate' }, { type: 'rare', value: 'encore', text: '앵콜', educationalDesc: '자신의 턴을<br>한 번 더 진행', color: 'slate' }, { type: 'rare', value: 'knight', text: '나이트', educationalDesc: '체스 나이트처럼<br>한 칸 이동', color: 'slate' }, { type: 'rare', value: 'gigantify', text: '거대화', educationalDesc: '1턴간 2x2 크기로<br>영역을 확장', color: 'slate' }, { type: 'rare', value: 'rewind', text: '도르마무', educationalDesc: '이전 위치로<br>되돌아갑니다', color: 'slate' }, ];

        let currentQuiz = null, quizTimerInterval = null; let debugClickSequence = []; let turnTimerInterval = null;

        window.onload = () => { 
            players.p1.pieceEl = player1Piece; 
            players.p2.pieceEl = player2Piece;
            players.p1.gigantifiedEl = document.getElementById('player1Gigantified');
            players.p2.gigantifiedEl = document.getElementById('player2Gigantified');
            window.addEventListener('resize', adjustLayout); 
            xAxisLabel.addEventListener('click', (e) => handleDebugClick(e, 'X')); 
            yAxisLabel.addEventListener('click', (e) => handleDebugClick(e, 'Y')); 
            gameBoard.addEventListener('click', handleBoardClick); 
            document.getElementById('summonCardBtn').addEventListener('click', toggleSummonList);
            document.getElementById('closeSummonListBtn').addEventListener('click', toggleSummonList);
            document.getElementById('rulebookBtn').addEventListener('click', showRulebook);
            document.getElementById('closeRulebookBtn').addEventListener('click', hideRulebook);
        };
        
        function handleDebugClick(e, axis) { e.stopPropagation(); debugClickSequence.push(axis); if (debugClickSequence.length > 2) debugClickSequence.shift(); if (debugClickSequence.join('') === 'XY') { isDebugMode = !isDebugMode; showToast(`디버그 모드 ${isDebugMode ? '활성화' : '비활성화'}`, isDebugMode ? 'bg-red-500' : 'bg-green-500'); debugClickSequence = []; debugPanel.classList.toggle('hidden'); updateButtons(); if (isDebugMode) { stopTurnTimer(); } else { startTurnTimer(); } } }
        function adjustLayout() { if (gameMode !== '') { mainContentArea.style.paddingBottom = `${bottomPanel.offsetHeight}px`; setupGameBoard(); } }
        function startGame(mode) { gameMode = mode; modeSelectionScreen.classList.add('hidden'); gameContainer.classList.remove('hidden'); gameContainer.classList.add('flex'); if (gameMode === 'pvp') { scoreboard.classList.remove('hidden'); opponentHandContainer.classList.remove('hidden'); turnTimerContainer.classList.remove('hidden'); } else { scoreboard.classList.add('hidden'); opponentHandContainer.classList.add('hidden'); turnTimerContainer.classList.add('hidden'); } adjustLayout(); newGame(); }
        function exitToMenu() { gameContainer.classList.add('hidden'); gameContainer.classList.remove('flex'); modeSelectionScreen.classList.remove('hidden'); pvpScores = { p1: 0, p2: 0 }; isDebugMode = false; debugPanel.classList.add('hidden'); stopTurnTimer(); }

        function setupGameBoard() {
            if (gameMode === '') return;
            const boardSize = gameBoard.clientWidth, unit = boardSize / (GRID_SIZE + 1);
            const gridDotsContainer = document.getElementById('gridDots'), axisLabelsContainer = document.getElementById('axisLabels');
            gridDotsContainer.innerHTML = ''; axisLabelsContainer.innerHTML = '';
            for (let i = 0; i <= GRID_SIZE; i++) for (let j = 0; j <= GRID_SIZE; j++) { const dot = document.createElement('div'); dot.className = 'grid-dot absolute'; dot.style.left = `${i * unit + unit/2 - 2.5}px`; dot.style.top = `${j * unit + unit/2 - 2.5}px`; gridDotsContainer.appendChild(dot); }
            for (let i = GRID_MIN; i <= GRID_MAX; i++) { 
                if (i === 0) continue; 
                const xLabel = document.createElement('span'); 
                xLabel.className = 'absolute text-xs font-medium text-gray-500'; 
                xLabel.textContent = i; 
                xLabel.style.top = '50%'; 
                xLabel.style.left = `${(i - GRID_MIN) * unit + unit/2}px`; 
                xLabel.style.transform = `translate(${i > 0 ? '-20%' : '-80%'}, 8px)`; 
                axisLabelsContainer.appendChild(xLabel); 
                
                const yLabel = document.createElement('span'); 
                yLabel.className = 'absolute text-xs font-medium text-gray-500'; 
                yLabel.textContent = i; 
                yLabel.style.left = '50%'; 
                yLabel.style.top = `${(GRID_MAX - i) * unit + unit/2}px`; 
                yLabel.style.transform = `translate(8px, ${i > 0 ? '-70%' : '-45%'})`; 
                axisLabelsContainer.appendChild(yLabel); 
            }
            updateAllPiecePositions();
        }

        function newGame() {
            currentTurn = 1; cardsUsedThisTurn = 0; selectedCard = null; selectedCardElement = null; quizSolvedThisTurn = false; quizBtn.disabled = false; isEncoreActive = false;
            if (gameMode === 'practice') {
                player1Piece.innerHTML = '🚀'; player2Piece.classList.add('hidden'); targetGoal.classList.remove('hidden');
                do { practicePlayer.pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; practicePlayer.targetPos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while (Math.abs(practicePlayer.pos.x - practicePlayer.targetPos.x) + Math.abs(practicePlayer.pos.y - practicePlayer.targetPos.y) < 6);
                practicePlayer.cards = []; practicePlayer.previousPos = null; drawInitialCards();
            } else {
                currentPlayerId = nextRoundStarterId || 'p1';
                nextRoundStarterId = null;
                player1Piece.innerHTML = players.p1.character; player2Piece.innerHTML = players.p2.character;
                player2Piece.classList.remove('hidden'); targetGoal.classList.add('hidden');
                let p1Pos, p2Pos;
                do { p1Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; p2Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while ((p1Pos.x === p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === p2Pos.x && p1Pos.y === -p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === -p2Pos.y) || (Math.abs(p1Pos.x - p2Pos.x) + Math.abs(p1Pos.y - p2Pos.y) < 4));
                players.p1.pos = p1Pos; players.p2.pos = p2Pos;
                players.p1.cards = []; players.p2.cards = [];
                players.p1.previousPos = null; players.p2.previousPos = null;
                players.p1.isGigantified = false; players.p2.isGigantified = false;
                drawInitialCards('p1'); drawInitialCards('p2');
            }
            updateUI();
            startTurnTimer();
            if (currentTurn === 1 && pvpScores.p1 === 0 && pvpScores.p2 === 0) { showToast(`${gameMode === 'practice' ? '연습' : 'PvP'} 모드 시작!`, 'bg-blue-500'); }
        }

        function createCardElement(cardData, isMini = false) { const cardElement = document.createElement('div'); const colorMap = { blue: 'text-blue-600', orange: 'text-orange-600', green: 'text-green-600', teal: 'text-teal-600', purple: 'text-purple-600', red: 'text-red-600', indigo: 'text-indigo-600', slate: 'text-slate-600' }; let bgClass = 'bg-white'; let borderClass = 'border-gray-200'; if (cardData.type === 'special') { bgClass = 'bg-sky-50'; borderClass = 'border-sky-200'; } else if (cardData.type === 'rare') { bgClass = 'bg-yellow-50'; borderClass = 'border-yellow-200'; } if (isMini) { cardElement.className = `${bgClass} border ${borderClass} rounded-md p-2 shadow-sm flex-shrink-0`; cardElement.innerHTML = `<div class="text-center"><div class="text-xs font-bold ${colorMap[cardData.color] || 'text-gray-800'}">${cardData.text}</div></div>`; } else { cardElement.className = `card-hover ${bgClass} border-2 ${borderClass} rounded-xl p-4 cursor-pointer shadow-md flex-shrink-0`; cardElement.onclick = () => selectCard(cardElement, cardData); cardElement.innerHTML = `<div class="text-center"><div class="text-lg font-bold ${colorMap[cardData.color] || 'text-gray-800'} mb-2">${cardData.text}</div><div class="text-xs text-gray-500 h-8 flex items-center justify-center">${cardData.educationalDesc}</div></div>`; } return cardElement; }
        function renderPlayerCards() { cardContainer.innerHTML = ''; const currentCards = (gameMode === 'practice') ? practicePlayer.cards : players[currentPlayerId].cards; currentCards.forEach(cardData => { const cardElement = createCardElement(cardData, false); cardContainer.appendChild(cardElement); }); }
        function renderOpponentCards() { opponentHandContainer.innerHTML = ''; if (gameMode !== 'pvp') return; const opponentId = currentPlayerId === 'p1' ? 'p2' : 'p1'; const opponent = players[opponentId]; opponentHandContainer.innerHTML = `<div class="flex items-center gap-2 bg-gray-900/10 backdrop-blur-sm p-2 rounded-lg"><span class="font-bold text-sm mr-2 text-white">${opponent.character} 상대방 카드:</span></div>`; const cardWrapper = opponentHandContainer.querySelector('div'); opponent.cards.forEach(cardData => { const cardElement = createCardElement(cardData, true); cardWrapper.appendChild(cardElement); }); }
        function drawInitialCards(playerId) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[playerId]; for (let i = 0; i < 4; i++) { targetPlayer.cards.push(cardDeck[Math.floor(Math.random() * cardDeck.length)]); } targetPlayer.cards.push(specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]); }
        function drawNewCards(count, playerId) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[playerId]; for (let i = 0; i < count; i++) { const rand = Math.random(); let drawnCard; if (gameMode === 'pvp' && rand < 0.1) { drawnCard = rareCardDeck[Math.floor(Math.random() * rareCardDeck.length)]; } else if (rand < 0.3) { drawnCard = specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]; } else { drawnCard = cardDeck[Math.floor(Math.random() * cardDeck.length)]; } targetPlayer.cards.push(drawnCard); } }
        function addCardToHand(cardData) { const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId]; targetPlayer.cards.push(cardData); renderPlayerCards(); }
        function selectCard(element, data) { if (selectedCardElement && selectedCardElement !== element) selectedCardElement.classList.remove('card-selected'); element.classList.toggle('card-selected'); if (element.classList.contains('card-selected')) { selectedCard = data; selectedCardElement = element; } else { selectedCard = null; selectedCardElement = null; } updateButtons(); }
        
        function useSelectedCard() {
            const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
            if (!selectedCard || (!isDebugMode && cardsUsedThisTurn >= MAX_CARDS_PER_TURN)) return;
            
            if (selectedCard.type === 'move' || selectedCard.type === 'special' || (selectedCard.type === 'rare' && ['sniper', 'magnet', 'rewind'].includes(selectedCard.value))) {
                targetPlayer.previousPos = { ...targetPlayer.pos }; 
            }

            const elementToRemove = selectedCardElement; 
            let newPos = { ...targetPlayer.pos }; let success = true;

            if (selectedCard.type === 'move' || selectedCard.type === 'special') {
                if (selectedCard.type === 'move') { newPos.x += selectedCard.value.x || 0; newPos.y += selectedCard.value.y || 0; } 
                else { if (selectedCard.value === 'origin') newPos = { x: -targetPlayer.pos.x, y: -targetPlayer.pos.y }; else if (selectedCard.value === 'x-axis') newPos = { x: targetPlayer.pos.x, y: -targetPlayer.pos.y }; else if (selectedCard.value === 'y-axis') newPos = { x: -targetPlayer.pos.x, y: targetPlayer.pos.y }; }
            } else if (selectedCard.type === 'rare') {
                const me = targetPlayer; const opponent = players[currentPlayerId === 'p1' ? 'p2' : 'p1'];
                switch(selectedCard.value) {
                    case 'sniper': if (me.pos.x === opponent.pos.x || me.pos.y === opponent.pos.y) { showToast('사정거리 포착! 상대방을 추격합니다!', 'bg-red-700'); newPos = { ...opponent.pos }; } else { showToast('상대방이 사정거리에 없습니다.', 'bg-gray-500'); success = false; } break;
                    case 'emergency_escape': showToast('비상탈출! 위치를 재설정합니다!', 'bg-yellow-500'); let p1Pos, p2Pos; do { p1Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; p2Pos = { x: getRandomInt(GRID_MIN, GRID_MAX), y: getRandomInt(GRID_MIN, GRID_MAX) }; } while ((p1Pos.x === p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === p2Pos.x && p1Pos.y === -p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === p2Pos.y) || (p1Pos.x === -p2Pos.x && p1Pos.y === -p2Pos.y) || (Math.abs(p1Pos.x - p2Pos.x) + Math.abs(p1Pos.y - p2Pos.y) < 4)); players.p1.pos = p1Pos; players.p2.pos = p2Pos; newPos = players[currentPlayerId].pos; break;
                    case 'magnet': const dist = Math.abs(me.pos.x - opponent.pos.x) + Math.abs(me.pos.y - opponent.pos.y); if (dist <= 4) { showToast('상대방이 너무 가깝습니다!', 'bg-gray-500'); success = false; } else { showToast('자석 발동! 상대방을 끌어옵니다!', 'bg-blue-700'); let stepsToPull = dist - 4; let opponentNewPos = { ...opponent.pos }; while (stepsToPull > 0) { const dx = me.pos.x - opponentNewPos.x; const dy = me.pos.y - opponentNewPos.y; if (Math.abs(dx) > Math.abs(dy)) { opponentNewPos.x += Math.sign(dx); } else { opponentNewPos.y += Math.sign(dy); } stepsToPull--; } opponent.pos = opponentNewPos; } break;
                    case 'encore': showToast('앵콜! 턴을 한 번 더 진행합니다!', 'bg-pink-500'); isEncoreActive = true; break;
                    case 'knight': showToast('나이트 이동! 이동할 위치를 선택하세요.', 'bg-gray-700'); isKnightMoveActive = true; me.pieceEl.innerHTML = '♞'; success = false; const cardIdx = me.cards.indexOf(selectedCard); if (cardIdx > -1) me.cards.splice(cardIdx, 1); renderPlayerCards(); break;
                    case 'gigantify': showToast('거대화! 1턴간 2x2 영역으로 확장됩니다.', 'bg-yellow-500'); me.isGigantified = true; break;
                    case 'rewind': if(me.previousPos) { showToast('도르마무! 이전 위치로 돌아갑니다.', 'bg-orange-500'); newPos = { ...me.previousPos }; } else { showToast('되돌아갈 위치가 없습니다.', 'bg-gray-500'); success = false; } break;
                }
            }
            if (!success) { selectCard(selectedCardElement, selectedCard); return; }

            newPos.x = Math.max(GRID_MIN, Math.min(GRID_MAX, newPos.x)); newPos.y = Math.max(GRID_MIN, Math.min(GRID_MAX, newPos.y));
            targetPlayer.pos = newPos; 
            if (selectedCard.value !== 'knight') { const cardIndex = targetPlayer.cards.indexOf(selectedCard); if (cardIndex > -1) targetPlayer.cards.splice(cardIndex, 1); }
            if (!isDebugMode) cardsUsedThisTurn++;
            elementToRemove.classList.add('card-use-animation'); const pieceEl = (gameMode === 'practice') ? player1Piece : targetPlayer.pieceEl;
            pieceEl.style.transition = 'all 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
            pieceEl.style.transform = `scale(${targetPlayer.isGigantified ? 2.4 : 1.2}) rotate(-10deg)`;
            setTimeout(() => { 
                pieceEl.style.transform = `scale(${targetPlayer.isGigantified ? 2 : 1}) ${targetPlayer.isGigantified ? 'translate(-25%, -25%)' : ''}`;
                checkWinCondition(); 
            }, 600);
            selectedCard = null; selectedCardElement = null; updateUI();
        }

        function discardCard() { if (!selectedCardElement) return; const elementToRemove = selectedCardElement; const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId]; const cardIndex = targetPlayer.cards.indexOf(selectedCard); if (cardIndex > -1) targetPlayer.cards.splice(cardIndex, 1); elementToRemove.style.transition = 'transform 0.3s, opacity 0.3s'; elementToRemove.style.transform = 'scale(0.8)'; elementToRemove.style.opacity = '0'; setTimeout(() => { renderPlayerCards(); }, 300); selectedCard = null; selectedCardElement = null; updateButtons(); }

        function endTurn() {
            stopTurnTimer();
            if (isEncoreActive) { isEncoreActive = false; cardsUsedThisTurn = 0; quizSolvedThisTurn = false; quizBtn.disabled = false; updateUI(); startTurnTimer(); showToast(`${players[currentPlayerId].name}의 앵콜 턴!`, 'bg-pink-500'); return; }
            const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
            if (targetPlayer.isGigantified) { targetPlayer.isGigantified = false; }
            let excess = 0;
            if (targetPlayer.cards.length > MAX_HAND_SIZE) {
                excess = targetPlayer.cards.length - MAX_HAND_SIZE;
                targetPlayer.cards.splice(0, excess);
                showToast(`카드가 6장을 초과하여, 가장 오래된 카드 ${excess}장을 버립니다.`, 'bg-orange-500');
            }

            const turnEndAction = () => {
                cardsUsedThisTurn = 0; quizSolvedThisTurn = false; quizBtn.disabled = false; 
                if (gameMode === 'practice') { currentTurn++; drawNewCards(2, null); } 
                else { 
                    if (currentPlayerId === 'p2') {
                        currentTurn++;
                        drawNewCards(2, 'p1');
                        drawNewCards(2, 'p2');
                    }
                    currentPlayerId = (currentPlayerId === 'p1') ? 'p2' : 'p1'; 
                }
                updateUI(); showToast(`${gameMode === 'pvp' ? players[currentPlayerId].name : ''} 턴 시작!`, 'bg-indigo-500'); 
                startTurnTimer();
            };
            
            setTimeout(turnEndAction, excess > 0 ? 1000 : 0);
        }
        
        function checkWinCondition() { 
            if (gameMode === 'practice') { if (practicePlayer.pos.x === practicePlayer.targetPos.x && practicePlayer.pos.y === practicePlayer.targetPos.y) { showToast(`🎉 목표 달성! ${currentTurn}턴 만에 성공!`, 'bg-green-500', 3000); stopTurnTimer(); setTimeout(newGame, 3500); } } 
            else { 
                const p1 = players.p1; const p2 = players.p2; let winnerId = null;
                const p1Hitbox = p1.isGigantified ? [{x:p1.pos.x, y:p1.pos.y}, {x:p1.pos.x-1, y:p1.pos.y}, {x:p1.pos.x, y:p1.pos.y+1}, {x:p1.pos.x-1, y:p1.pos.y+1}] : [p1.pos];
                const p2Hitbox = p2.isGigantified ? [{x:p2.pos.x, y:p2.pos.y}, {x:p2.pos.x-1, y:p2.pos.y}, {x:p2.pos.x, y:p2.pos.y+1}, {x:p2.pos.x-1, y:p2.pos.y+1}] : [p2.pos];
                
                for (const h1 of p1Hitbox) { for (const h2 of p2Hitbox) { if (h1.x === h2.x && h1.y === h2.y) { winnerId = currentPlayerId; break; } } if (winnerId) break; }

                if (winnerId) { 
                    const winner = players[winnerId]; 
                    nextRoundStarterId = winnerId === 'p1' ? 'p2' : 'p1';
                    pvpScores[winnerId]++; 
                    updateScoreboard(); 
                    showToast(`🎉 ${winner.name} 승리!`, 'bg-green-500', 3000); 
                    stopTurnTimer(); 
                    setTimeout(newGame, 3500); 
                }
            } 
        }

        function showQuiz() { if (quizSolvedThisTurn) { showToast('퀴즈는 턴 당 한 번만 풀 수 있습니다.', 'bg-orange-500'); return; } currentQuiz = generateQuizData(); document.getElementById('quizQuestion').innerHTML = currentQuiz.question.replace(/\n/g, '<br>'); const optionsContainer = document.getElementById('quizOptions'); optionsContainer.innerHTML = ''; currentQuiz.options.forEach((option, index) => { const label = document.createElement('label'); label.className = "flex items-center p-3 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-gray-50 transition"; label.innerHTML = `<input type="radio" name="quiz" value="${index}" class="mr-3 h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"><span>${option}</span>`; optionsContainer.appendChild(label); }); quizModal.classList.remove('hidden'); quizModal.classList.add('flex'); let timeLeft = 30; if (isDebugMode) return; const timerEl = document.getElementById('quizTimer'); timerEl.textContent = timeLeft; quizTimerInterval = setInterval(() => { timeLeft--; timerEl.textContent = timeLeft; if (timeLeft <= 0) { clearInterval(quizTimerInterval); showToast('시간 초과! 카드를 얻지 못했습니다.', 'bg-red-500'); quizSolvedThisTurn = true; quizBtn.disabled = true; closeQuiz(); } }, 1000); }
        function submitQuiz() { const selected = document.querySelector('input[name="quiz"]:checked'); if (!selected) { showToast('답을 선택해주세요!', 'bg-red-500'); return; } clearInterval(quizTimerInterval); quizSolvedThisTurn = true; quizBtn.disabled = true; if (parseInt(selected.value) === currentQuiz.correctIndex) { const rand = Math.random(); if (rand < 0.3) { showToast('정답! 레어 카드를 획득했습니다!', 'bg-yellow-400'); addCardToHand(rareCardDeck[Math.floor(Math.random() * rareCardDeck.length)]); } else { showToast('정답! 특수 카드를 획득했습니다!', 'bg-green-500'); addCardToHand(specialCardDeck[Math.floor(Math.random() * specialCardDeck.length)]); } } else { showToast(`오답입니다! 정답은 ${currentQuiz.options[currentQuiz.correctIndex]} 입니다.`, 'bg-orange-500', 4000); } closeQuiz(); }
        function closeQuiz() { clearInterval(quizTimerInterval); quizModal.classList.add('hidden'); quizModal.classList.remove('flex'); }
        const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min; const getRandomNonZeroInt = (min, max) => { let num; do { num = getRandomInt(min, max); } while (num === 0); return num; }; function formatLine(m, b) { let str = 'y = '; if (m === 1) str += 'x'; else if (m === -1) str += '-x'; else if (m !== 0) str += `${m}x`; if (b > 0) str += (m !== 0 ? ' + ' : '') + `${b}`; else if (b < 0) str += ` - ${-b}`; if (m === 0 && b === 0) return 'y = 0'; return str; } function formatCircle(h, k, r) { let str = ''; if (h === 0) str += 'x²'; else str += `(x ${h > 0 ? '-' : '+'} ${Math.abs(h)})²`; str += ' + '; if (k === 0) str += 'y²'; else str += `(y ${k > 0 ? '-' : '+'} ${Math.abs(k)})²`; str += ` = ${r*r}`; return str; } function generateQuizData() { const type = getRandomInt(0, 3); switch (type) { case 0: return generateTranslateLineQuiz(); case 1: return generateReflectLineQuiz(); case 2: return generateTranslateCircleQuiz(); case 3: return generateReflectCircleQuiz(); } } function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; } function generateTranslateLineQuiz() { const m = getRandomNonZeroInt(-2, 2), b = getRandomInt(-3, 3), dx = getRandomNonZeroInt(-3, 3), dy = getRandomNonZeroInt(-3, 3); const question = `직선 ${formatLine(m, b)}를\nx축 방향으로 ${dx}만큼, y축 방향으로 ${dy}만큼\n평행이동한 방정식은?`; const correct = formatLine(m, -m * dx + b + dy); const distractors = [ formatLine(m, m * dx + b - dy), formatLine(m, -m * dx + b - dy), formatLine(m, m * dx + b + dy) ]; const options = shuffle([correct, ...new Set(distractors.filter(d => d !== correct))].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateReflectLineQuiz() { const m = getRandomInt(0,1) === 0 ? 1 : -1, b = getRandomInt(-3, 3); const types = ['x축', 'y축', '원점', '직선 y=x'], type = types[getRandomInt(0, 3)]; const question = `직선 ${formatLine(m, b)}를\n${type}에 대칭이동한 방정식은?`; let correct, distractors; if (type === 'x축') { correct = formatLine(-m, -b); distractors = [formatLine(-m, b), formatLine(m, -b), formatLine(m, b), formatLine(1/m, b)]; } else if (type === 'y축') { correct = formatLine(-m, b); distractors = [formatLine(-m, -b), formatLine(m, -b), formatLine(m, b), formatLine(1/m, -b)]; } else if (type === '원점') { correct = formatLine(m, -b); distractors = [formatLine(-m, -b), formatLine(-m, b), formatLine(m, b), formatLine(-1/m, b)]; } else { correct = formatLine(1/m, -b/m); distractors = [formatLine(m, b), formatLine(-m, b), formatLine(m, -b), formatLine(-m, -b)]; } const options = shuffle([correct, ...new Set(distractors.filter(d => d !== correct))].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateTranslateCircleQuiz() { const h = getRandomInt(-3, 3), k = getRandomInt(-3, 3), r = getRandomInt(1, 4), dx = getRandomNonZeroInt(-3, 3), dy = getRandomNonZeroInt(-3, 3); const question = `원 ${formatCircle(h, k, r)}를\nx축 방향으로 ${dx}만큼, y축 방향으로 ${dy}만큼\n평행이동한 방정식은?`; const correct = formatCircle(h + dx, k + dy, r); const distractors = [ formatCircle(h - dx, k - dy, r), formatCircle(h + dx, k + dy, r + 1), formatCircle(h, k, r) ]; const options = shuffle([correct, ...new Set(distractors)].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; } function generateReflectCircleQuiz() { const h = getRandomInt(-3, 3), k = getRandomInt(-3, 3), r = getRandomInt(1, 4); const types = ['x축', 'y축', '원점', '직선 y=x'], type = types[getRandomInt(0, 3)]; const question = `원 ${formatCircle(h, k, r)}를\n${type}에 대칭이동한 방정식은?`; let correct, distractors; if (type === 'x축') { correct = formatCircle(h, -k, r); distractors = [formatCircle(-h, k, r), formatCircle(h, k, r), formatCircle(h, -k, r+1)]; } else if (type === 'y축') { correct = formatCircle(-h, k, r); distractors = [formatCircle(h, -k, r), formatCircle(h, k, r), formatCircle(-h, k, r+1)]; } else if (type === '원점') { correct = formatCircle(-h, -k, r); distractors = [formatLine(h, -k, r), formatCircle(-h, k, r), formatCircle(-h, -k, r+1)]; } else { correct = formatCircle(k, h, r); distractors = [formatCircle(-k, -h, r), formatCircle(h, k, r), formatCircle(k, h, r+1)]; } const options = shuffle([correct, ...new Set(distractors)].slice(0, 4)); return { question, options, correctIndex: options.indexOf(correct) }; }

        function coordToPixel(pos) { const boardSize = gameBoard.clientWidth, unit = boardSize / (GRID_SIZE + 1); return { left: (pos.x - GRID_MIN) * unit + unit / 2 - 36 / 2, top: (GRID_MAX - pos.y) * unit + unit / 2 - 36 / 2 }; }
        function updateAllPiecePositions() { if (gameMode === 'practice') { const practicePos = coordToPixel(practicePlayer.pos); player1Piece.style.left = `${practicePos.left}px`; player1Piece.style.top = `${practicePos.top}px`; const targetPos = coordToPixel(practicePlayer.targetPos); targetGoal.style.left = `${targetPos.left + 4}px`; targetGoal.style.top = `${targetPos.top + 4}px`; } else { const p1Pos = coordToPixel(players.p1.pos); player1Piece.style.left = `${p1Pos.left}px`; player1Piece.style.top = `${p1Pos.top}px`; const p2Pos = coordToPixel(players.p2.pos); player2Piece.style.left = `${p2Pos.left}px`; player2Piece.style.top = `${p2Pos.top}px`; } }
        function updateUI() { updateAllPiecePositions(); renderPlayerCards(); if(gameMode === 'pvp') { renderOpponentCards(); players.p1.gigantifiedEl.classList.toggle('hidden', !players.p1.isGigantified); players.p2.gigantifiedEl.classList.toggle('hidden', !players.p2.isGigantified); if(players.p1.isGigantified) { const gPos = coordToPixel({x: players.p1.pos.x - 1, y: players.p1.pos.y + 1}); const gSize = (gameBoard.clientWidth / (GRID_SIZE + 1)) * 2; players.p1.gigantifiedEl.style.left = `${gPos.left}px`; players.p1.gigantifiedEl.style.top = `${gPos.top}px`; players.p1.gigantifiedEl.style.width = `${gSize}px`; players.p1.gigantifiedEl.style.height = `${gSize}px`; players.p1.pieceEl.style.transform = `scale(2) translate(-25%, -25%)`; } else { players.p1.pieceEl.style.transform = 'scale(1)'; } if(players.p2.isGigantified) { const gPos = coordToPixel({x: players.p2.pos.x - 1, y: players.p2.pos.y + 1}); const gSize = (gameBoard.clientWidth / (GRID_SIZE + 1)) * 2; players.p2.gigantifiedEl.style.left = `${gPos.left}px`; players.p2.gigantifiedEl.style.top = `${gPos.top}px`; players.p2.gigantifiedEl.style.width = `${gSize}px`; players.p2.gigantifiedEl.style.height = `${gSize}px`; players.p2.pieceEl.style.transform = `scale(2) translate(-25%, -25%)`; } else { players.p2.pieceEl.style.transform = 'scale(1)'; } } turnDisplayEl.textContent = `턴 ${currentTurn}`; if (gameMode === 'practice') { infoPanelTitle.textContent = '게임 정보'; turnIndicator.textContent = '연습 모드'; infoPanelContent.innerHTML = `<div class="flex justify-between items-center"><span class="text-gray-600">현재 위치:</span><span class="font-semibold text-blue-600 text-lg">(${practicePlayer.pos.x}, ${practicePlayer.pos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">목표 지점:</span><span class="font-semibold text-green-600 text-lg">(${practicePlayer.targetPos.x}, ${practicePlayer.targetPos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">남은 거리:</span><span class="font-semibold text-red-500 text-lg">${Math.abs(practicePlayer.pos.x - practicePlayer.targetPos.x) + Math.abs(practicePlayer.pos.y - practicePlayer.targetPos.y)} 칸</span></div>`; } else { const currentPlayer = players[currentPlayerId]; const opponentPlayer = players[currentPlayerId === 'p1' ? 'p2' : 'p1']; infoPanelTitle.textContent = `${currentPlayer.character} ${currentPlayer.name}`; infoPanelTitle.className = `text-xl font-bold mb-4 ${currentPlayerId === 'p1' ? 'text-cyan-600' : 'text-purple-600'}`; turnIndicator.textContent = `PvP 모드`; infoPanelContent.innerHTML = `<div class="flex justify-between items-center"><span class="text-gray-600">나의 위치:</span><span class="font-semibold text-blue-600 text-lg">(${currentPlayer.pos.x}, ${currentPlayer.pos.y})</span></div><div class="flex justify-between items-center"><span class="text-gray-600">상대 위치:</span><span class="font-semibold text-red-500 text-lg">(${opponentPlayer.pos.x}, ${opponentPlayer.pos.y})</span></div>`; } updateButtons(); }
        function updateScoreboard() { p1ScoreEl.textContent = pvpScores.p1; p2ScoreEl.textContent = pvpScores.p2; }
        function updateButtons() { useCardBtn.textContent = `카드 사용 (${isDebugMode ? '∞' : cardsUsedThisTurn + '/' + MAX_CARDS_PER_TURN})`; useCardBtn.disabled = !selectedCard || (!isDebugMode && cardsUsedThisTurn >= MAX_CARDS_PER_TURN); discardCardBtn.disabled = !selectedCard; quizBtn.disabled = quizSolvedThisTurn; }
        function showToast(message, bgColor, duration = 3000) { const toast = document.createElement('div'); toast.textContent = message; toast.className = `toast-notification ${bgColor}`; document.getElementById('toastContainer').appendChild(toast); setTimeout(() => { toast.style.opacity = '1'; toast.style.top = '40px'; }, 10); setTimeout(() => { toast.style.opacity = '0'; toast.style.top = '20px'; setTimeout(() => toast.remove(), 500); }, duration); }

        // --- 턴 타이머 기능 ---
        function startTurnTimer() { if (isDebugMode || gameMode === 'practice') { turnTimerContainer.classList.add('hidden'); return; } turnTimerContainer.classList.remove('hidden'); stopTurnTimer(); let timeLeft = TURN_TIME_LIMIT; turnTimerBar.style.width = '100%'; turnTimerInterval = setInterval(() => { timeLeft--; const percentage = (timeLeft / TURN_TIME_LIMIT) * 100; turnTimerBar.style.width = `${percentage}%`; if (timeLeft <= 0) { showToast('시간 초과! 턴이 자동으로 종료됩니다.', 'bg-red-500'); endTurn(); } }, 1000); }
        function stopTurnTimer() { clearInterval(turnTimerInterval); }
        
        // --- 나이트 기능 ---
        function handleBoardClick(e) {
            const rect = gameBoard.getBoundingClientRect(); const unit = gameBoard.clientWidth / (GRID_SIZE + 1);
            const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top;
            const targetCoord = { x: Math.round((clickX - unit/2) / unit) + GRID_MIN, y: GRID_MAX - Math.round((clickY - unit/2) / unit) };
            
            if (isKnightMoveActive) {
                const me = players[currentPlayerId];
                const dx = Math.abs(targetCoord.x - me.pos.x);
                const dy = Math.abs(targetCoord.y - me.pos.y);
                if ((dx === 1 && dy === 2) || (dx === 2 && dy === 1)) {
                    me.previousPos = { ...me.pos };
                    me.pos = targetCoord;
                    isKnightMoveActive = false;
                    me.pieceEl.innerHTML = me.character;
                    if (!isDebugMode) cardsUsedThisTurn++;
                    selectedCard = null; selectedCardElement = null;
                    updateUI();
                    checkWinCondition();
                } else {
                    showToast('나이트가 이동할 수 없는 위치입니다.', 'bg-orange-500');
                }
            } else if (isDebugMode) {
                const targetPlayer = (gameMode === 'practice') ? practicePlayer : players[currentPlayerId];
                targetPlayer.pos = targetCoord;
                updateUI(); showToast(`순간이동: (${targetCoord.x}, ${targetCoord.y})`, 'bg-red-500');
            }
        }
        
        // --- 디버그 기능 ---
        function toggleSummonList() { summonListModal.classList.toggle('hidden'); summonListModal.classList.toggle('flex'); if (!summonListModal.classList.contains('hidden')) { populateSummonList(); } }
        function populateSummonList() {
            summonListContainer.innerHTML = '';
            const allCards = [...cardDeck, ...specialCardDeck, ...rareCardDeck];
            allCards.forEach(card => {
                const cardEl = createCardElement(card, false);
                cardEl.onclick = () => {
                    addCardToHand(card);
                    toggleSummonList();
                };
                summonListContainer.appendChild(cardEl);
            });
        }

        // --- 룰북 기능 ---
        function showRulebook() {
            rulebookContent.innerHTML = `
                <h3 class="text-xl font-bold mb-2">게임 컨셉</h3>
                <p class="mb-4">이 게임은 좌표평면 위에서 카드를 사용하여 자신의 말을 움직여 목표를 달성하는 전략 보드게임입니다. 수학적 사고력과 전략적 판단력을 동시에 요구합니다.</p>
                
                <h3 class="text-xl font-bold mb-2">게임 모드</h3>
                <ul class="list-disc list-inside mb-4">
                    <li><b>연습 모드:</b> 혼자서 목표 지점(🎯)에 도달하는 것을 목표로 합니다. 게임의 기본적인 규칙과 카드 사용법을 익히기에 좋습니다.</li>
                    <li><b>PvP 모드:</b> 두 명의 플레이어가 상대방의 말을 잡기 위해 경쟁합니다. 자신의 턴에 상대방과 같은 칸에 도착하면 승리합니다.</li>
                </ul>

                <h3 class="text-xl font-bold mb-2">게임 진행</h3>
                <ul class="list-disc list-inside mb-4">
                    <li>자신의 턴에 최대 2장의 카드를 사용할 수 있습니다.</li>
                    <li>'퀴즈 도전' 버튼을 눌러 수학 퀴즈를 풀 수 있습니다. (턴 당 1회)</li>
                    <li>퀴즈를 맞히면 '특수 카드'(70%) 또는 '레어 카드'(30%)를 보상으로 얻습니다.</li>
                    <li>손에 들 수 있는 카드는 최대 6장입니다. 턴 종료 시 6장을 초과하면 가장 오래된 카드부터 자동으로 버려집니다.</li>
                    <li>PvP 모드에서는 각 턴마다 2분의 시간 제한이 있습니다.</li>
                </ul>

                <h3 class="text-xl font-bold mb-2">카드 등급</h3>
                <p class="mb-4">카드는 일반, 특수, 레어 세 가지 등급으로 나뉩니다.</p>
                <ul class="list-disc list-inside mb-4">
                    <li><b>일반 카드 (흰색):</b> x축 또는 y축 방향으로 말을 이동시킵니다.</li>
                    <li><b>특수 카드 (하늘색):</b> x축, y축, 원점 대칭이동과 같은 특별한 움직임을 제공합니다.</li>
                    <li><b>레어 카드 (노란색):</b> 게임의 판도를 뒤집을 수 있는 강력하고 희귀한 효과를 가집니다.</li>
                </ul>

                <h4 class="text-lg font-bold mt-4 mb-2">레어 카드 상세 설명</h4>
                <ul class="list-disc list-inside space-y-2">
                    <li><b>저격총:</b> 자신의 말과 상대방의 말이 같은 가로줄이나 세로줄에 있을 때, 즉시 상대방을 잡아 승리합니다.</li>
                    <li><b>비상탈출:</b> 두 플레이어의 위치를 맵 위의 무작위 위치로 즉시 재설정합니다.</li>
                    <li><b>자석:</b> 상대방을 자신의 말 쪽으로 끌어당겨, 둘 사이의 거리를 4칸으로 만듭니다. (4칸 이하일 경우 사용 불가)</li>
                    <li><b>앵콜:</b> 이번 턴을 마친 뒤, 상대방에게 턴을 넘기지 않고 자신의 턴을 한 번 더 진행합니다.</li>
                    <li><b>나이트:</b> 말을 체스 나이트(♞)처럼 한 칸 이동시킵니다.</li>
                    <li><b>거대화:</b> 1턴간 자신의 말이 2x2 영역을 차지하게 됩니다. 이 영역에 상대방이 닿으면 승리합니다.</li>
                    <li><b>도르마무:</b> 마지막으로 이동 카드를 사용하기 전의 위치로 되돌아갑니다.</li>
                </ul>
            `;
            rulebookModal.classList.remove('hidden');
            rulebookModal.classList.add('flex');
        }
        function hideRulebook() {
            rulebookModal.classList.add('hidden');
            rulebookModal.classList.remove('flex');
        }
    </script>
</body>
</html>